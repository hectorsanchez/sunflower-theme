<script type="text/javascript">
// Discourse Admin Users Location Column
// Este script agrega una columna "Location" a la vista de administración de usuarios

// Función para esperar a que Discourse esté completamente cargado
function waitForDiscourse() {
  return new Promise((resolve) => {
    if (window.Discourse && window.Discourse.__container__) {
      resolve();
    } else {
      const checkInterval = setInterval(() => {
        if (window.Discourse && window.Discourse.__container__) {
          clearInterval(checkInterval);
          resolve();
        }
      }, 100);
    }
  });
}

// Función para esperar a que un elemento esté disponible en el DOM
function waitForElement(selector, timeout = 10000) {
  return new Promise((resolve, reject) => {
    const element = document.querySelector(selector);
    if (element) {
      resolve(element);
      return;
    }

    const observer = new MutationObserver((mutations, obs) => {
      const element = document.querySelector(selector);
      if (element) {
        obs.disconnect();
        resolve(element);
      }
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true
    });

    // Timeout después de 10 segundos
    setTimeout(() => {
      observer.disconnect();
      reject(new Error(`Elemento ${selector} no encontrado después de ${timeout}ms`));
    }, timeout);
  });
}

// Función para encontrar la tabla de usuarios (admin o pública)
function findUsersTable() {
  // Intentar diferentes selectores para encontrar la tabla
  const selectors = [
    '.directory-table.users-list',
    '.directory-table[role="table"]',
    '.directory-table', // Para vista pública
    '.users-list',
    '.admin-users-list',
    '.admin-users table',
    '.admin-users-table table',
    'table.admin-users-table',
    'table.admin-users',
    'table.users-table'
  ];

  for (const selector of selectors) {
    try {
      const element = document.querySelector(selector);
      if (element) {
        console.log(`Tabla encontrada con selector: ${selector}`);
        return element;
      }
    } catch (e) {
      // Ignorar errores de selectores inválidos
    }
  }

  // Si no se encuentra con selectores específicos, buscar por contenido
  const allTables = document.querySelectorAll('[role="table"], table');
  for (const table of allTables) {
    const headers = table.querySelectorAll('[role="columnheader"], th');
    let hasUsername = false;
    let hasEmail = false;
    
    for (const header of headers) {
      const text = header.textContent.toLowerCase();
      if (text.includes('username') || text.includes('name')) {
        hasUsername = true;
      }
      if (text.includes('email')) {
        hasEmail = true;
      }
    }
    
    if (hasUsername && hasEmail) {
      console.log('Tabla encontrada por contenido (username + email)');
      return table;
    }
  }

  return null;
}

// Función para analizar la estructura de la tabla encontrada
function analyzeTableStructure(table) {
  // Verificar si es una tabla moderna de Discourse (CSS Grid + ARIA)
  if (table.classList.contains('directory-table') || table.getAttribute('role') === 'table') {
    
    // Buscar encabezados de columna
    const columnHeaders = table.querySelectorAll('.directory-table__column-header, [role="columnheader"]');
    if (columnHeaders.length > 0) {
      
      // Buscar filas de datos
      const dataRows = table.querySelectorAll('.directory-table__row, [role="row"]:not([role="columnheader"])');
      
      return { 
        type: 'modern', 
        table, 
        columnHeaders: Array.from(columnHeaders), 
        dataRows: Array.from(dataRows) 
      };
    }
  }
  
  // Verificar si tiene thead/tbody tradicional
  const thead = table.querySelector('thead');
  const tbody = table.querySelector('tbody');
  
  if (thead && tbody) {
    console.log('Estructura tradicional: thead + tbody');
    return { type: 'traditional', thead, tbody };
  }
  
  // Si no tiene thead/tbody, buscar filas directamente
  const allRows = table.querySelectorAll('tr');
  if (allRows.length > 0) {
    console.log(`Encontradas ${allRows.length} filas en la tabla`);
    
    // La primera fila suele ser el encabezado
    const headerRow = allRows[0];
    const dataRows = Array.from(allRows).slice(1);
    
    console.log('Estructura alternativa: filas directas');
    return { type: 'alternative', headerRow, dataRows, allRows };
  }
  
  // Si no hay filas, buscar en elementos hijos
  const childElements = table.children;

  
  return null;
}

// Función para agregar event listeners de manera compatible
function addEventListenerSafe(element, event, handler) {
  if (element && typeof element.addEventListener === 'function') {
    element.addEventListener(event, handler);
  }
}

// Cache para almacenar las ubicaciones de los usuarios (solo memoria, sin API calls)
const userLocationCache = new Map();

// Variables globales para el manejo de scroll infinito
let currentTable = null;
let currentDataRows = [];
let locationFilter = null;
let filterCounter = null;
let filterSelect = null;

// Cargar cache desde localStorage al iniciar
function loadCacheFromStorage() {
  try {
    const stored = localStorage.getItem('userLocationCache');
    if (stored) {
      const cacheData = JSON.parse(stored);
      Object.entries(cacheData).forEach(([key, value]) => {
        userLocationCache.set(key, value);
      });
      console.log(`Cache cargado: ${userLocationCache.size} ubicaciones`);
    }
  } catch (error) {
    console.log('Error cargando cache desde localStorage:', error);
  }
}

// Guardar cache en localStorage
function saveCacheToStorage() {
  try {
    const cacheData = Object.fromEntries(userLocationCache);
    localStorage.setItem('userLocationCache', JSON.stringify(cacheData));
  } catch (error) {
    console.log('Error guardando cache en localStorage:', error);
  }
}

// Función para extraer ubicación directamente del DOM sin llamadas a la API
function extractLocationFromDOM(username) {
  // Verificar cache primero, pero re-extraer si es "N/A" (podría ser un error previo)
  if (userLocationCache.has(username)) {
    const cachedLocation = userLocationCache.get(username);
    // Debug específico para "Read Time" en cache
    if (cachedLocation === 'Read Time') {
      console.log(`DEBUG: "Read Time" encontrado en cache para usuario ${username}`);
    }
    // Si el cache tiene "N/A", intentar re-extraer
    if (cachedLocation === 'N/A') {
      console.log(`DEBUG: Re-extraendo ubicación para usuario ${username} (tenía N/A en cache)`);
    } else {
      return cachedLocation;
    }
  }
  
  console.log(`DEBUG: Extrayendo ubicación para usuario ${username}`);
  let location = 'N/A';
  
  // Buscar enlaces de perfil del usuario en la página actual
  const userLinks = document.querySelectorAll(`a[href*="/u/${username}"]`);
  console.log(`DEBUG: Encontrados ${userLinks.length} enlaces para usuario ${username}`);
  
  for (const link of userLinks) {
    // Buscar en el contexto del enlace por información de ubicación
    const userCard = link.closest('.user-card') || link.closest('.directory-table__row') || link.closest('tr');
    
    if (userCard) {
      console.log(`DEBUG: userCard encontrado para usuario ${username}`);
      // Buscar en elementos de texto que puedan contener ubicación
      const textElements = userCard.querySelectorAll('span, div, td, .directory-table__cell');
      console.log(`DEBUG: Encontrados ${textElements.length} elementos de texto para usuario ${username}`);
      
      for (const element of textElements) {
        const text = element.textContent.trim();
        
        // Buscar patrones de ubicación comunes
        if (isValidLocation(text)) {
          // Verificar si es un país conocido
          const country = extractCountryFromLocation(text);
          if (country !== 'Sin ubicación') {
            location = country;
            break;
          }
        }
      }
      
      if (location !== 'N/A') break;
    }
  }
  
  // Si no se encontró en el DOM, intentar extraer de información ya disponible
  if (location === 'N/A') {
    // Buscar específicamente en la fila del usuario
    const userRow = document.querySelector(`a[href*="/u/${username}"]`)?.closest('.directory-table__row, tr');
    
    if (userRow) {
      // Buscar en todas las celdas de la fila específica del usuario
      const cells = userRow.querySelectorAll('.directory-table__cell, td');
      
      for (const cell of cells) {
        const cellText = cell.textContent.trim();
        
        // Buscar patrones de ubicación en las celdas
        if (isValidLocation(cellText)) {
          const country = extractCountryFromLocation(cellText);
          if (country !== 'Sin ubicación') {
            location = country;
            break;
          }
        }
      }
    }
  }
  
  // Si aún no se encontró, intentar extraer de atributos data o información oculta
  if (location === 'N/A') {
    // Buscar en elementos con atributos data que puedan contener información de ubicación
    const dataElements = document.querySelectorAll('[data-user-location], [data-location], [title*="location" i], [title*="ubicación" i]');
    
    for (const element of dataElements) {
      const title = element.getAttribute('title') || '';
      const dataLocation = element.getAttribute('data-user-location') || element.getAttribute('data-location') || '';
      
      if (title || dataLocation) {
        const text = (title + ' ' + dataLocation).trim();
        const country = extractCountryFromLocation(text);
        if (country !== 'Sin ubicación') {
          location = country;
          break;
        }
      }
    }
  }
  
  // Si aún no se encontró, buscar en el perfil del usuario (si está disponible)
  if (location === 'N/A') {
    // Buscar en elementos que puedan contener información de perfil
    const profileElements = document.querySelectorAll('[data-user-profile], [data-profile], .user-profile, .profile-info');
    
    for (const element of profileElements) {
      const text = element.textContent.trim();
      if (isValidLocation(text)) {
        const country = extractCountryFromLocation(text);
        if (country !== 'Sin ubicación') {
          location = country;
          break;
        }
      }
    }
  }
  
  // Si aún no se encontró, buscar en todos los elementos de la fila del usuario
  if (location === 'N/A') {
    const userRow = document.querySelector(`a[href*="/u/${username}"]`)?.closest('.directory-table__row, tr');
    
    if (userRow) {
      console.log(`DEBUG: Buscando en todos los elementos de la fila para usuario ${username}`);
      
      // Buscar en todos los elementos de la fila, incluyendo elementos anidados
      const allElements = userRow.querySelectorAll('*');
      console.log(`DEBUG: Encontrados ${allElements.length} elementos en la fila para usuario ${username}`);
      
      for (const element of allElements) {
        const text = element.textContent.trim();
        
        // Solo procesar texto que no sea muy largo y que no sea el username
        if (text.length > 2 && text.length < 50 && text !== username) {
          if (isValidLocation(text)) {
            const country = extractCountryFromLocation(text);
            if (country !== 'Sin ubicación') {
              location = country;
              console.log(`DEBUG: Ubicación encontrada en elemento para usuario ${username}: "${text}" -> "${country}"`);
              break;
            }
          }
        }
      }
    }
  }
  
  // Si aún no se encontró, buscar en atributos title y data-* de todos los elementos
  if (location === 'N/A') {
    const userRow = document.querySelector(`a[href*="/u/${username}"]`)?.closest('.directory-table__row, tr');
    
    if (userRow) {
      console.log(`DEBUG: Buscando en atributos de la fila para usuario ${username}`);
      
      const allElements = userRow.querySelectorAll('*');
      
      for (const element of allElements) {
        // Buscar en atributos title
        const title = element.getAttribute('title');
        if (title && title.length > 2 && title.length < 50) {
          if (isValidLocation(title)) {
            const country = extractCountryFromLocation(title);
            if (country !== 'Sin ubicación') {
              location = country;
              console.log(`DEBUG: Ubicación encontrada en atributo title para usuario ${username}: "${title}" -> "${country}"`);
              break;
            }
          }
        }
        
        // Buscar en atributos data-*
        const attributes = element.attributes;
        for (const attr of attributes) {
          if (attr.name.startsWith('data-') && attr.value && attr.value.length > 2 && attr.value.length < 50) {
            if (isValidLocation(attr.value)) {
              const country = extractCountryFromLocation(attr.value);
              if (country !== 'Sin ubicación') {
                location = country;
                console.log(`DEBUG: Ubicación encontrada en atributo ${attr.name} para usuario ${username}: "${attr.value}" -> "${country}"`);
                break;
              }
            }
          }
        }
        
        if (location !== 'N/A') break;
      }
    }
  }
      
  // Debug si se está guardando "Read Time"
  if (location === 'Read Time') {
    console.log(`DEBUG: ERROR - Se está guardando "Read Time" en cache para usuario ${username}`);
    console.log(`DEBUG: Esto no debería pasar si isValidLocation funciona correctamente`);
    // Forzar a N/A para evitar guardar "Read Time"
    location = 'N/A';
  }
  
  console.log(`DEBUG: Resultado final para usuario ${username}: "${location}"`);
  
  // Guardar en cache
  userLocationCache.set(username, location);
  saveCacheToStorage();
  
  return location;
}

// Función para obtener ubicación (ahora sin API calls)
function getUserLocation(username) {
  return extractLocationFromDOM(username);
}

// Función para procesar nuevas filas que se agreguen dinámicamente
function processNewRows() {
  if (!currentTable) return;
  
  const allRows = currentTable.querySelectorAll('.directory-table__row, tr');
  const newRows = [];
  
  // Encontrar filas que no tienen la columna de ubicación
  allRows.forEach(row => {
    if (!row.querySelector('.location-column-data')) {
      newRows.push(row);
    }
  });
  
  if (newRows.length > 0) {
    console.log(`Procesando ${newRows.length} nuevas filas`);
    
    // Procesar las nuevas filas
    newRows.forEach(row => {
      addLocationCellToModernRow(row);
    });
    
    // Actualizar la lista de filas de datos
    currentDataRows = Array.from(currentTable.querySelectorAll('.directory-table__row, tr'));
    
    // Actualizar el contador y filtro
    updateFilterAndCounter();
  }
}

// Función para actualizar el filtro y contador
function updateFilterAndCounter() {
  if (!currentTable || !filterCounter || !filterSelect) return;
  
  // Actualizar contador
  const visibleRows = currentTable.querySelectorAll('.directory-table__row:not([style*="display: none"])');
  const totalRows = currentDataRows.length;
  filterCounter.textContent = `${visibleRows.length} of ${totalRows} users`;
  
  // Actualizar opciones del filtro
  updateLocationOptions();
}

// Función para actualizar opciones del filtro
function updateLocationOptions() {
  if (!currentTable || !filterSelect) return;
  
  const locations = new Set();
  const locationCells = currentTable.querySelectorAll('.location-column-data');
  
  locationCells.forEach(cell => {
    const location = cell.textContent.trim();
    if (location && location !== 'N/A' && location !== 'Sin ubicación') {
      locations.add(location);
    }
  });
  
  // Limpiar opciones existentes (excepto las primeras dos)
  while (filterSelect.children.length > 2) {
    filterSelect.removeChild(filterSelect.lastChild);
  }
  
  // Agregar opciones de ubicaciones
  const sortedLocations = Array.from(locations).sort();
  sortedLocations.forEach(location => {
    const option = document.createElement('option');
    option.value = location;
    option.textContent = location;
    filterSelect.appendChild(option);
  });
}

// Función para configurar el MutationObserver para detectar scroll infinito
function setupInfiniteScrollObserver() {
  if (!currentTable) return;
  
  // Crear un observer para detectar cambios en el DOM
  const observer = new MutationObserver(function(mutations) {
    let shouldProcess = false;
    
    mutations.forEach(function(mutation) {
      // Verificar si se agregaron nuevos nodos
      if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
        mutation.addedNodes.forEach(function(node) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            // Verificar si es una fila de tabla o contiene filas
            if (node.classList && (node.classList.contains('directory-table__row') || node.querySelector('.directory-table__row'))) {
              shouldProcess = true;
            }
          }
        });
      }
    });
    
    if (shouldProcess) {
      // Usar setTimeout para evitar procesar demasiado frecuentemente
      // Aumentar delay para asegurar que el DOM esté completamente renderizado
      setTimeout(processNewRows, 500);
    }
  });
  
  // Observar cambios en el contenedor de la tabla
  const tableContainer = currentTable.parentNode;
  if (tableContainer) {
    observer.observe(tableContainer, {
      childList: true,
      subtree: true
    });
  }
  
  // También observar cambios directamente en la tabla
  observer.observe(currentTable, {
    childList: true,
    subtree: true
  });
  
  console.log('MutationObserver configurado para scroll infinito');
}

// Inicializar cache al cargar
loadCacheFromStorage();
// Limpiar entradas inválidas del cache
cleanInvalidCacheEntries();
// Limpiar entradas N/A del cache para permitir re-extracción
cleanNACacheEntries();
// Limpiar entradas de fecha/hora del cache
cleanDateTimeCacheEntries();

// Función para validar si un texto es una ubicación válida
function isValidLocation(text) {
  if (!text || text.length < 2 || text.length > 100) {
    return false;
  }
  
  // Debug para ver qué texto se está evaluando
  if (text.length > 2 && text.length < 50) {
    console.log(`DEBUG: Evaluando texto: "${text}"`);
  }
  
  // Verificación específica para "Read Time" y otros textos de UI comunes
  const uiTexts = [
    'read time', 'last emailed', 'seen', 'topics viewed', 'posts read', 
    'created', 'status', 'joined', 'posts', 'topics', 'likes', 'active', 
    'new', 'staff', 'suspended', 'silenced', 'staged', 'trust', 'level',
    'admin', 'moderator', 'user', 'member', 'online', 'offline', 'away',
    'busy', 'do not disturb', 'profile', 'avatar', 'email', 'username',
    'name', 'title', 'role', 'permissions', 'settings', 'preferences',
    'account', 'login', 'logout', 'search', 'filter', 'sort', 'order',
    'date', 'updated', 'deleted', 'archived', 'hidden', 'private', 'public',
    'draft', 'published', 'pending', 'approved', 'rejected', 'flagged',
    'reported', 'banned', 'muted', 'warned', 'restricted', 'limited',
    'days', 'hours', 'minutes', 'seconds', 'ago', 'today', 'yesterday',
    'week', 'month', 'year', 'january', 'february', 'march', 'april',
    'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december',
    'am', 'pm', 'morning', 'afternoon', 'evening', 'night', 'midnight', 'noon'
  ];
  
  const lowerText = text.toLowerCase();
  
  // Verificar si es exactamente uno de los textos de UI
  for (const uiText of uiTexts) {
    if (lowerText === uiText || lowerText.includes(uiText)) {
      console.log(`DEBUG: Texto "${text}" rechazado por ser texto de UI: "${uiText}"`);
      return false;
    }
  }
  
  // Verificar patrones de texto que NO son ubicaciones
  if (text.includes('@') || 
      text.includes('http') ||
      text.includes('www') ||
      text.match(/^\d+$/) ||
      text.match(/^\d+[a-z]*$/) ||
      text.match(/^[a-z]+\d+$/) ||
      text.match(/\d{4}-\d{2}-\d{2}/) || // fechas
      text.match(/\d{2}:\d{2}/) || // horas
      text.match(/^\d+[a-z]+\d+$/) || // patrones como "2days"
      text.match(/^< \d+[a-z]+$/) || // patrones como "< 1m"
      text.match(/^\d+[a-z]+$/) || // patrones como "2h", "3mon"
      text.match(/^[a-z]+\d+[a-z]+$/) || // patrones como "mar2h"
      text.match(/^\d{4} \d{1,2}:\d{2} [ap]m$/) || // patrones como "2025 8:56 pm"
      text.match(/^[A-Za-z]{3} \d{1,2}, \d{4} \d{1,2}:\d{2} [ap]m$/) || // patrones como "Sep 19, 2025 8:56 pm"
      text.match(/^[A-Za-z]{3} \d{1,2}, \d{4}$/) || // patrones como "Sep 19, 2025"
      text.match(/^\d{1,2}:\d{2} [ap]m$/) || // patrones como "8:56 pm"
      text.match(/^\d{4}$/) || // solo años como "2025"
      text.match(/^\d{1,2}:\d{2}$/) || // patrones como "8:56"
      text.match(/^[A-Za-z]{3} \d{1,2}$/) || // patrones como "Sep 19"
      text.match(/^\d{1,2}\/\d{1,2}\/\d{4}$/) || // patrones como "19/09/2025"
      text.match(/^\d{4}-\d{1,2}-\d{1,2}$/)) { // patrones como "2025-09-19"
    console.log(`DEBUG: Texto "${text}" rechazado por patrón inválido (fecha/hora)`);
    return false;
  }
  
  // Verificar si contiene solo caracteres especiales o símbolos
  if (text.match(/^[^a-zA-Z0-9\s,.-]+$/)) {
    console.log(`DEBUG: Texto "${text}" rechazado por contener solo caracteres especiales`);
    return false;
  }
  
  // Verificar si es muy corto y no parece una ubicación
  if (text.length < 3 && !text.match(/^[A-Z][a-z]+$/)) {
    console.log(`DEBUG: Texto "${text}" rechazado por ser muy corto`);
    return false;
  }
  
  // Verificar si contiene al menos una letra
  if (!/[a-zA-Z]/.test(text)) {
    console.log(`DEBUG: Texto "${text}" rechazado por no contener letras`);
    return false;
  }
  
  // Verificar si parece un username (solo minúsculas, números, puntos, guiones bajos)
  if (text.match(/^[a-z0-9._-]+$/) && text.length > 3) {
    console.log(`DEBUG: Texto "${text}" rechazado por parecer username`);
    return false;
  }
  
  console.log(`DEBUG: Texto "${text}" ACEPTADO como ubicación válida`);
  return true;
}

// Función para extraer el país de la ubicación (basada en tu script de Python)
function extractCountryFromLocation(location) {
  if (!location || location === 'N/A') {
    return 'Sin ubicación';
  }

  // Validar que sea una ubicación válida
  if (!isValidLocation(location)) {
    return 'Sin ubicación';
  }

  // Si la ubicación contiene una coma, tomar la última parte (país)
  if (location.includes(',')) {
    const parts = location.split(',');
    const country = parts[parts.length - 1].trim();
    return isValidLocation(country) ? country : 'Sin ubicación';
  }

  // Si no hay coma, asumir que es solo el país
  return location.trim();
}

// Función para agregar la columna Location
async function addLocationColumn() {
  try {
    // Verificar si estamos en una página de usuarios (admin o pública)
    const isAdminUsersPage = window.location.pathname.includes('/admin/users/list/');
    const isPublicUsersPage = window.location.pathname.includes('/u') && 
      (window.location.search.includes('order=') || window.location.pathname === '/u');
    
    if (!isAdminUsersPage && !isPublicUsersPage) {
      return;
    }
    
    // Esperar un poco más para que la página se cargue completamente
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Buscar la tabla usando nuestra función personalizada
    const table = findUsersTable();
    if (!table) {
      // Intentar de nuevo en unos segundos
      setTimeout(addLocationColumn, 3000);
      return;
    }
    
    // Analizar la estructura de la tabla
    const structure = analyzeTableStructure(table);
    if (!structure) {
      return;
    }
    
    // Verificar si ya se agregó la columna
    if (table.querySelector('.location-column-header')) {
      return;
    }
    
    if (structure.type === 'modern') {
      // Estructura moderna de Discourse (CSS Grid + ARIA)
      addColumnToModernTable(structure.table, structure.columnHeaders, structure.dataRows);
    } else if (structure.type === 'traditional') {
      // Estructura tradicional con thead/tbody
      addColumnToTraditionalTable(structure.thead, structure.tbody);
    } else if (structure.type === 'alternative') {
      // Estructura alternativa con filas directas
      addColumnToAlternativeTable(structure.headerRow, structure.dataRows);
    }
    
    // Aplicar estilos CSS personalizados
    applyLocationColumnStyles();
    
  } catch (error) {
    // Intentar de nuevo en unos segundos
    setTimeout(addLocationColumn, 3000);
  }
}

// Función para agregar columna a tabla moderna de Discourse
function addColumnToModernTable(table, columnHeaders, dataRows) {
  // Guardar referencias globales para el manejo de scroll infinito
  currentTable = table;
  currentDataRows = dataRows;
  
  // Crear encabezado de columna
  const locationHeader = document.createElement('div');
  locationHeader.className = 'directory-table__column-header location-column-header sortable';
  locationHeader.setAttribute('aria-sort', 'none');
  locationHeader.setAttribute('role', 'columnheader');
  
  const headerContents = document.createElement('div');
  headerContents.className = 'header-contents';
  headerContents.setAttribute('role', 'button');
  headerContents.setAttribute('tabindex', '0');
  headerContents.setAttribute('aria-label', 'Location');
  headerContents.setAttribute('aria-pressed', 'false');
  
  const textSpan = document.createElement('span');
  textSpan.className = 'text';
  textSpan.textContent = 'Location';
  
  headerContents.appendChild(textSpan);
  locationHeader.appendChild(headerContents);
  
  // Insertar el encabezado antes del último encabezado existente
  if (columnHeaders.length > 0) {
    const lastHeader = columnHeaders[columnHeaders.length - 1];
    lastHeader.parentNode.insertBefore(locationHeader, lastHeader.nextSibling);
  } else {
    // Si no hay encabezados, insertar en el contenedor de encabezados
    const headerContainer = table.querySelector('.directory-table__header');
    if (headerContainer) {
      headerContainer.appendChild(locationHeader);
    }
  }
  
  // Agregar celdas de datos
  for (const row of dataRows) {
    addLocationCellToModernRow(row);
  }
  
  // Actualizar el CSS Grid para incluir la nueva columna
  updateGridColumns(table);
  
  // Agregar filtro por ubicación
  addLocationFilter(table, dataRows);
}

// Función para agregar celda de ubicación a una fila moderna
function addLocationCellToModernRow(row) {
  const locationCell = document.createElement('div');
  locationCell.className = 'directory-table__cell location-column-data';
  locationCell.setAttribute('role', 'cell');
  
  // Obtener el username de la fila
  const usernameCell = row.querySelector('.directory-table__cell.username');
  let username = '';
  
  if (usernameCell) {
    // Buscar el enlace del username (el segundo enlace con clase ember-view)
    const usernameLink = usernameCell.querySelector('a.ember-view');
    
    if (usernameLink) {
      username = usernameLink.textContent.trim();
    } else {
      // Intentar otros selectores para la vista pública
      const avatarLink = usernameCell.querySelector('a.avatar');
      if (avatarLink) {
        const href = avatarLink.getAttribute('href');
        if (href && href.startsWith('/u/')) {
          username = href.split('/u/')[1];
        }
      }
      
      if (!username) {
        username = usernameCell.textContent.trim();
      }
    }
  } else {
    // Intentar otros selectores para la vista pública
    const allCells = row.querySelectorAll('.directory-table__cell');
    
    for (const cell of allCells) {
      const links = cell.querySelectorAll('a');
      for (const link of links) {
        const href = link.getAttribute('href');
        if (href && href.startsWith('/u/')) {
          username = href.split('/u/')[1];
          break;
        }
      }
      if (username) break;
    }
  }
  
  if (username) {
    // Obtener ubicación directamente del DOM (sin API calls)
    const location = getUserLocation(username);
    
      locationCell.textContent = location;
      locationCell.style.fontStyle = 'normal';
      locationCell.style.color = '#40312a';
    locationCell.style.fontSize = '0.9em';
      
      // Aplicar estilos especiales para ubicaciones válidas
    if (location !== 'N/A' && location !== 'Sin ubicación') {
        locationCell.style.fontWeight = '500';
        locationCell.style.color = '#8A4A19';
    } else {
      locationCell.style.color = '#999';
      locationCell.style.fontStyle = 'italic';
      }
  } else {
    locationCell.textContent = 'N/A';
    locationCell.style.color = '#999';
    locationCell.style.fontStyle = 'italic';
  }
  
  // Insertar la celda en la posición correcta
  const lastCell = row.querySelector('.directory-table__cell:last-child');
  if (lastCell) {
    row.insertBefore(locationCell, lastCell.nextSibling);
  } else {
    row.appendChild(locationCell);
  }
}

// Función para actualizar las columnas del CSS Grid
function updateGridColumns(table) {
  const currentStyle = table.style.gridTemplateColumns;
  if (currentStyle) {
    // Agregar una columna más al grid
    const newStyle = currentStyle.replace(/\)$/, ' minmax(min-content, 1fr))');
    table.style.gridTemplateColumns = newStyle;
    console.log('CSS Grid actualizado para incluir la nueva columna');
  }
}

// Función para agregar filtro por ubicación
function addLocationFilter(table, dataRows) {
  console.log('Agregando filtro por ubicación...');
  
  // Crear el contenedor del filtro
  const filterContainer = document.createElement('div');
  filterContainer.className = 'location-filter-container';
  filterContainer.style.cssText = `
    margin: 10px 0;
    padding: 10px;
    background-color: var(--bg-tertiary);
    border: 1px solid var(--border-primary);
    border-radius: 4px;
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
  `;
  
  // Crear etiqueta
  const label = document.createElement('label');
  label.textContent = 'Filter by Location:';
  label.style.cssText = `
    font-weight: 600;
    color: var(--text-primary);
    margin-right: 5px;
  `;
  
  // Crear dropdown
  const select = document.createElement('select');
  select.className = 'location-filter-select';
  select.style.cssText = `
    padding: 5px 10px;
    border: 1px solid #e0c052;
    border-radius: 4px;
    background-color: var(--bg-primary);
    color: var(--text-primary);
    font-size: 14px;
    min-width: 150px;
  `;
  
  // Agregar opciones iniciales
  const allOption = document.createElement('option');
  allOption.value = 'all';
  allOption.textContent = 'All users';
  select.appendChild(allOption);
  
  const noLocationOption = document.createElement('option');
  noLocationOption.value = 'no-location';
  noLocationOption.textContent = 'No location';
  select.appendChild(noLocationOption);
  
  // Crear contador
  const counter = document.createElement('span');
  counter.className = 'location-filter-counter';
  counter.style.cssText = `
    color: var(--text-secondary);
    font-weight: 500;
    font-size: 14px;
  `;
  
  // Guardar referencias globales
  filterCounter = counter;
  filterSelect = select;
  
  // Función para actualizar el contador
  function updateCounter() {
    const visibleRows = table.querySelectorAll('.directory-table__row:not([style*="display: none"])');
    const totalRows = currentDataRows.length;
    counter.textContent = `${visibleRows.length} of ${totalRows} users`;
  }
  
  // Función para filtrar
  function filterByLocation(selectedLocation) {
    console.log(`Filtrando por ubicación: ${selectedLocation}`);
    
    dataRows.forEach(row => {
      const locationCell = row.querySelector('.location-column-data');
      if (locationCell) {
        const cellLocation = locationCell.textContent.trim();
        
        if (selectedLocation === 'all') {
          row.style.display = '';
        } else if (selectedLocation === 'no-location') {
          row.style.display = (cellLocation === 'N/A' || cellLocation === 'Sin ubicación') ? '' : 'none';
        } else {
          row.style.display = (cellLocation === selectedLocation) ? '' : 'none';
        }
      }
    });
    
    updateCounter();
  }
  
  // Event listener para el filtro
  select.addEventListener('change', (e) => {
    filterByLocation(e.target.value);
  });
  
  // Ensamblar el filtro
  filterContainer.appendChild(label);
  filterContainer.appendChild(select);
  filterContainer.appendChild(counter);
  
  // Insertar el filtro antes de la tabla
  const tableContainer = table.closest('.directory-table-container') || table.parentNode;
  if (tableContainer) {
    tableContainer.insertBefore(filterContainer, table);
  }
  
  // Actualizar contador inicial
  updateCounter();
  
  // Actualizar opciones inmediatamente (ya que no hay API calls)
  updateLocationOptions();
  
  // Configurar MutationObserver para detectar nuevas filas
  setupInfiniteScrollObserver();
  
  console.log('Filtro por ubicación agregado exitosamente');
}

// Función para agregar columna a tabla tradicional
function addColumnToTraditionalTable(thead, tbody) {
  const headerRow = thead.querySelector('tr');
  if (!headerRow) return;
  
  // Agregar encabezado de columna
  const locationHeader = document.createElement('th');
  locationHeader.className = 'location-column-header';
  locationHeader.textContent = 'Location';
  locationHeader.style.minWidth = '120px';
  locationHeader.style.textAlign = 'center';
  
  // Insertar antes de la última columna
  const lastHeader = headerRow.querySelector('th:last-child');
  if (lastHeader) {
    headerRow.insertBefore(locationHeader, lastHeader);
  } else {
    headerRow.appendChild(locationHeader);
  }
  
  // Agregar celdas de datos
  const rows = tbody.querySelectorAll('tr');
  console.log(`Agregando celdas para ${rows.length} filas...`);
  
  for (const row of rows) {
    addLocationCellToRow(row);
  }
}

// Función para agregar columna a tabla alternativa
function addColumnToAlternativeTable(headerRow, dataRows) {
  // Agregar encabezado de columna
  const locationHeader = document.createElement('th');
  locationHeader.className = 'location-column-header';
  locationHeader.textContent = 'Location';
  locationHeader.style.minWidth = '120px';
  locationHeader.style.textAlign = 'center';
  
  // Insertar antes de la última columna
  const lastHeader = headerRow.querySelector('th:last-child');
  if (lastHeader) {
    headerRow.insertBefore(locationHeader, lastHeader);
  } else {
    headerRow.appendChild(locationHeader);
  }
  
  // Agregar celdas de datos
  console.log(`Agregando celdas para ${dataRows.length} filas...`);
  
  for (const row of dataRows) {
    addLocationCellToRow(row);
  }
}

// Función para agregar celda de ubicación a una fila tradicional
function addLocationCellToRow(row) {
  const locationCell = document.createElement('td');
  locationCell.className = 'location-column-data';
  locationCell.style.textAlign = 'center';
  locationCell.style.verticalAlign = 'middle';
  
  // Obtener el username de la fila
  const usernameLink = row.querySelector('td:first-child a');
  if (usernameLink) {
    const username = usernameLink.textContent.trim();
    
    // Obtener ubicación directamente del DOM (sin API calls)
    const location = getUserLocation(username);
    
      locationCell.textContent = location;
      locationCell.style.fontStyle = 'normal';
      locationCell.style.color = '#40312a';
    locationCell.style.fontSize = '0.9em';
      
      // Aplicar estilos especiales para ubicaciones válidas
    if (location !== 'N/A' && location !== 'Sin ubicación') {
        locationCell.style.fontWeight = '500';
        locationCell.style.color = '#8A4A19';
    } else {
      locationCell.style.color = '#999';
      locationCell.style.fontStyle = 'italic';
      }
  } else {
    locationCell.textContent = 'N/A';
    locationCell.style.color = '#999';
    locationCell.style.fontStyle = 'italic';
  }
  
  // Insertar la celda en la posición correcta
  const lastCell = row.querySelector('td:last-child');
  if (lastCell) {
    row.insertBefore(locationCell, lastCell);
  } else {
    row.appendChild(locationCell);
  }
}

// Función para aplicar estilos CSS del footer
function applyFooterStyles() {
  const style = document.createElement('style');
  style.setAttribute('data-footer-css', 'true');
  style.textContent = `
    /* Estilos para el footer personalizado de Youth Care Assembly */
    .yc-footer-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px 15px;
    }

    .yc-footer-divider {
      border: none;
      height: 1px;
      background-color: var(--border-secondary);
      margin: 0 0 30px 0;
    }

    .yc-footer-row {
      margin-bottom: 20px;
    }

    .yc-footer-logos {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 20px;
    }

    .yc-footer-logo {
      display: inline-block;
      transition: transform 0.3s ease, opacity 0.3s ease;
      text-decoration: none;
    }

    .yc-footer-logo:hover {
      transform: scale(1.05);
      opacity: 0.8;
    }

    .yc-footer-logo img {
      max-height: 60px;
      max-width: 120px;
      width: auto;
      height: auto;
      object-fit: contain;
      filter: grayscale(20%);
      transition: filter 0.3s ease;
    }

    .yc-footer-logo:hover img {
      filter: grayscale(0%);
    }

    /* Fila de información de la UE */
    .yc-footer-eu-row {
      margin-top: 30px;
      padding-top: 20px;
    }

    .yc-footer-eu-content {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 30px;
      flex-wrap: wrap;
    }

    .yc-footer-eu-logo {
      flex-shrink: 0;
    }

    .yc-footer-eu-logo img {
      max-height: 80px;
      max-width: 200px;
      width: auto;
      height: auto;
      object-fit: contain;
    }

    .yc-footer-eu-text {
      flex: 1;
      min-width: 300px;
      max-width: 600px;
    }

    .yc-footer-eu-text p {
      font-size: 10pt;
      font-family: Arial, sans-serif;
      color: var(--text-secondary);
      line-height: 1.4;
      margin: 0;
      text-align: center;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .yc-footer-container {
        padding: 15px 10px;
      }
      
      .yc-footer-logos {
        gap: 15px;
      }
      
      .yc-footer-logo img {
        max-height: 50px;
        max-width: 100px;
      }
      
      .yc-footer-eu-content {
        flex-direction: column;
        gap: 20px;
        text-align: center;
      }
      
      .yc-footer-eu-text {
        min-width: auto;
        max-width: none;
      }
      
      .yc-footer-eu-text p {
        font-size: 9pt;
      }
    }

    @media (max-width: 480px) {
      .yc-footer-logos {
        gap: 10px;
      }
      
      .yc-footer-logo img {
        max-height: 40px;
        max-width: 80px;
      }
      
      .yc-footer-eu-logo img {
        max-height: 60px;
        max-width: 150px;
      }
    }
  `;
  document.head.appendChild(style);
}

// Función para aplicar estilos CSS
function applyLocationColumnStyles() {
  const style = document.createElement('style');
  style.setAttribute('data-location-column', 'true');
  style.textContent = `
    .location-column-header {
      color: var(--text-primary) !important;
      font-weight: 600 !important;
      padding: 8px 12px !important;
      text-align: center !important;
      vertical-align: middle !important;
    }
    
    .location-column-data {
      color: var(--text-primary) !important;
      font-size: 0.9em !important;
      padding: 8px 12px !important;
      text-align: center !important;
      vertical-align: middle !important;
      transition: all 0.2s ease !important;
    }
    
    .location-column-data:hover {
      color: var(--text-primary) !important;
    }
    
    /* Estilos para tablas modernas de Discourse */
    .directory-table .location-column-header {
      color: var(--text-primary) !important;
      font-weight: 600 !important;
      padding: 8px 12px !important;
      text-align: center !important;
      vertical-align: middle !important;
    }
    
    .directory-table .location-column-data {
      color: var(--text-primary) !important;
      font-size: 0.9em !important;
      padding: 8px 12px !important;
      text-align: center !important;
      vertical-align: middle !important;
      transition: all 0.2s ease !important;
    }
    
    .directory-table .location-column-data:hover {
      color: var(--text-primary) !important;
    }
    
    /* Estilos para el filtro por ubicación */
    .location-filter-container {
      margin: 10px 0 !important;
      padding: 10px !important;
      background-color: var(--bg-tertiary) !important;
      border: 1px solid var(--border-primary) !important;
      border-radius: 4px !important;
      display: flex !important;
      align-items: center !important;
      gap: 10px !important;
    }
    
    .location-filter-container label {
      font-weight: 600 !important;
      color: var(--text-primary) !important;
      margin-right: 5px !important;
    }
    
    .location-filter-select {
      padding: 5px 10px !important;
      border: 1px solid #e0c052 !important;
      border-radius: 4px !important;
      background-color: var(--bg-primary) !important;
      color: var(--text-primary) !important;
      font-size: 14px !important;
      min-width: 150px !important;
    }
    
    .location-filter-select:hover {
      border-color: #d4b847 !important;
    }
    
    .location-filter-select:focus {
      outline: none !important;
      border-color: var(--text-secondary) !important;
      box-shadow: 0 0 0 2px rgba(138, 74, 25, 0.2) !important;
    }
    
    .location-filter-counter {
      color: var(--text-secondary) !important;
      font-weight: 500 !important;
      font-size: 14px !important;
    }
    
    .location-progress-indicator {
      color: var(--text-secondary) !important;
      font-size: 12px !important;
      font-style: italic !important;
      animation: pulse 2s infinite !important;
    }
    
    .loading-indicator {
      animation: pulse 1.5s infinite !important;
      color: #e0c052 !important;
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    /* Estilos para la tabla completa */
    .admin-users-table table,
    .admin-users table,
    .users-table table,
    .admin-users-list table,
    .admin-users-list,
    .directory-table {
      border-collapse: collapse !important;
    }
    
    .admin-users-table th,
    .admin-users-table td,
    .admin-users th,
    .admin-users td,
    .users-table th,
    .users-table td,
    .admin-users-list th,
    .admin-users-list td,
    .directory-table__column-header,
    .directory-table__cell {
    }
  `;
  document.head.appendChild(style);
}

// Función para limpiar la columna cuando se cambia de página
function cleanupLocationColumn() {
  const existingHeader = document.querySelector('.location-column-header');
  const existingCells = document.querySelectorAll('.location-column-data');
  const existingStyle = document.querySelector('style[data-location-column]');
  const existingFilter = document.querySelector('.location-filter-container');
  
  if (existingHeader) existingHeader.remove();
  existingCells.forEach(cell => cell.remove());
  if (existingStyle) existingStyle.remove();
  if (existingFilter) existingFilter.remove();
  
  // Resetear variables globales
  currentTable = null;
  currentDataRows = [];
  locationFilter = null;
  filterCounter = null;
  filterSelect = null;
}

// Función para limpiar el cache (útil para debugging o cuando se quiera refrescar datos)
function clearLocationCache() {
  userLocationCache.clear();
  localStorage.removeItem('userLocationCache');
  console.log('Cache de ubicaciones limpiado');
}

// Función para limpiar entradas específicas del cache que contengan "Read Time"
function cleanInvalidCacheEntries() {
  let cleaned = 0;
  for (const [username, location] of userLocationCache.entries()) {
    if (location === 'Read Time' || location.toLowerCase().includes('read time')) {
      userLocationCache.delete(username);
      cleaned++;
    }
  }
  
  if (cleaned > 0) {
    saveCacheToStorage();
    console.log(`Limpiadas ${cleaned} entradas inválidas del cache`);
  }
}

// Función para limpiar entradas "N/A" del cache y forzar re-extracción
function cleanNACacheEntries() {
  let cleaned = 0;
  for (const [username, location] of userLocationCache.entries()) {
    if (location === 'N/A') {
      userLocationCache.delete(username);
      cleaned++;
    }
  }
  
  if (cleaned > 0) {
    saveCacheToStorage();
    console.log(`Limpiadas ${cleaned} entradas N/A del cache para re-extracción`);
  }
}

// Función para limpiar entradas del cache que contengan fechas/horas
function cleanDateTimeCacheEntries() {
  let cleaned = 0;
  const dateTimePatterns = [
    /^\d{4} \d{1,2}:\d{2} [ap]m$/, // "2025 8:56 pm"
    /^[A-Za-z]{3} \d{1,2}, \d{4} \d{1,2}:\d{2} [ap]m$/, // "Sep 19, 2025 8:56 pm"
    /^[A-Za-z]{3} \d{1,2}, \d{4}$/, // "Sep 19, 2025"
    /^\d{1,2}:\d{2} [ap]m$/, // "8:56 pm"
    /^\d{4}$/, // "2025"
    /^\d{1,2}:\d{2}$/, // "8:56"
    /^[A-Za-z]{3} \d{1,2}$/, // "Sep 19"
    /^\d{1,2}\/\d{1,2}\/\d{4}$/, // "19/09/2025"
    /^\d{4}-\d{1,2}-\d{1,2}$/ // "2025-09-19"
  ];
  
  for (const [username, location] of userLocationCache.entries()) {
    for (const pattern of dateTimePatterns) {
      if (pattern.test(location)) {
        userLocationCache.delete(username);
        cleaned++;
        console.log(`Limpiada entrada de fecha/hora del cache: ${username} -> "${location}"`);
        break;
      }
    }
  }
  
  if (cleaned > 0) {
    saveCacheToStorage();
    console.log(`Limpiadas ${cleaned} entradas de fecha/hora del cache`);
  }
}

// Función para mostrar estadísticas del cache (útil para debugging)
function showCacheStats() {
  const cacheSize = userLocationCache.size;
  const localStorageSize = localStorage.getItem('userLocationCache') ? JSON.parse(localStorage.getItem('userLocationCache')).length : 0;
  
  console.log(`Estadísticas del cache:
    - Ubicaciones en cache: ${cacheSize}
    - Tamaño del cache en localStorage: ${localStorageSize} items`);
  
  return { cacheSize, localStorageSize };
}

// Función para debuggear el DOM de un usuario específico
function debugUserDOM(username) {
  console.log(`=== DEBUG DOM para usuario: ${username} ===`);
  
  const userRow = document.querySelector(`a[href*="/u/${username}"]`)?.closest('.directory-table__row, tr');
  
  if (!userRow) {
    console.log(`No se encontró fila para usuario ${username}`);
    return;
  }
  
  console.log(`Fila encontrada para usuario ${username}:`);
  console.log(userRow);
  
  // Mostrar todo el contenido de texto de la fila
  const allElements = userRow.querySelectorAll('*');
  console.log(`Total de elementos en la fila: ${allElements.length}`);
  
  const textContents = [];
  allElements.forEach((element, index) => {
    const text = element.textContent.trim();
    if (text && text.length > 0 && text.length < 100) {
      textContents.push({
        index: index,
        tagName: element.tagName,
        className: element.className,
        text: text
      });
    }
  });
  
  console.log('Contenidos de texto encontrados:');
  textContents.forEach(item => {
    console.log(`[${item.index}] ${item.tagName}.${item.className}: "${item.text}"`);
  });
  
  // Mostrar atributos de todos los elementos
  console.log('Atributos encontrados:');
  allElements.forEach((element, index) => {
    const attributes = element.attributes;
    if (attributes.length > 0) {
      console.log(`[${index}] ${element.tagName}.${element.className}:`);
      for (const attr of attributes) {
        if (attr.value && attr.value.length > 0 && attr.value.length < 100) {
          console.log(`  ${attr.name}: "${attr.value}"`);
        }
      }
    }
  });
  
  console.log(`=== FIN DEBUG DOM para usuario: ${username} ===`);
}

// Hacer funciones disponibles globalmente para debugging
window.clearLocationCache = clearLocationCache;
window.cleanInvalidCacheEntries = cleanInvalidCacheEntries;
window.cleanNACacheEntries = cleanNACacheEntries;
window.cleanDateTimeCacheEntries = cleanDateTimeCacheEntries;
window.showCacheStats = showCacheStats;
window.debugUserDOM = debugUserDOM;

// Función principal que se ejecuta cuando Discourse esté listo
async function initLocationColumn() {
  try {
    // Esperar a que Discourse esté completamente cargado
    await waitForDiscourse();
    
    console.log('Inicializando columna Location...');
    
    // Ejecutar cuando se carga la página
    await addLocationColumn();
    
    // Ejecutar cuando cambia la URL (navegación SPA de Discourse)
    let currentUrl = window.location.href;
    const observer = new MutationObserver(function() {
      if (window.location.href !== currentUrl) {
        currentUrl = window.location.href;
        
        // Limpiar columna anterior
        cleanupLocationColumn();
        
        // Agregar nueva columna
        setTimeout(addLocationColumn, 1000);
      }
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    
    // También ejecutar cuando se hace clic en enlaces de navegación
    document.addEventListener('click', function(event) {
      const target = event.target.closest('a');
      if (target && target.href) {
        const href = target.href;
        const isAdminUsersLink = href.includes('/admin/users/list/');
        const isPublicUsersLink = href.includes('/u') && (href.includes('order=') || href.endsWith('/u'));
        
        if (isAdminUsersLink || isPublicUsersLink) {
          setTimeout(() => {
            cleanupLocationColumn();
            addLocationColumn();
          }, 1000);
        }
      }
    });
    
    // Ejecutar cuando se cambia entre pestañas (Active, New, Staff, etc.) o ordenamientos públicos
    document.addEventListener('click', function(event) {
      const target = event.target.closest('a');
      if (target && target.classList.contains('ember-view')) {
        const href = target.getAttribute('href');
        if (href && (href.includes('/admin/users/list/') || href.includes('/admin/groups') || (href.includes('/u') && (href.includes('order=') || href.endsWith('/u'))))) {
          setTimeout(() => {
            cleanupLocationColumn();
            addLocationColumn();
          }, 1500);
        }
      }
    });
    
    console.log('Columna Location inicializada correctamente');
    
  } catch (error) {
    console.log('Error inicializando columna Location:', error);
  }
}

// Aplicar estilos del footer inmediatamente al cargar la página
applyFooterStyles();

// Iniciar cuando el DOM esté listo
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initLocationColumn);
} else {
  initLocationColumn();
}
</script>
