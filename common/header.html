<script type="text/javascript">
// Discourse Admin Users Location Column
// Este script agrega una columna "Location" a la vista de administración de usuarios

// Función para esperar a que Discourse esté completamente cargado
function waitForDiscourse() {
  return new Promise((resolve) => {
    if (window.Discourse && window.Discourse.__container__) {
      resolve();
    } else {
      const checkInterval = setInterval(() => {
        if (window.Discourse && window.Discourse.__container__) {
          clearInterval(checkInterval);
          resolve();
        }
      }, 100);
    }
  });
}

// Función para esperar a que un elemento esté disponible en el DOM
function waitForElement(selector, timeout = 10000) {
  return new Promise((resolve, reject) => {
    const element = document.querySelector(selector);
    if (element) {
      resolve(element);
      return;
    }

    const observer = new MutationObserver((mutations, obs) => {
      const element = document.querySelector(selector);
      if (element) {
        obs.disconnect();
        resolve(element);
      }
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true
    });

    // Timeout después de 10 segundos
    setTimeout(() => {
      observer.disconnect();
      reject(new Error(`Elemento ${selector} no encontrado después de ${timeout}ms`));
    }, timeout);
  });
}

// Función para encontrar la tabla de usuarios (admin o pública)
function findUsersTable() {
  // Intentar diferentes selectores para encontrar la tabla
  const selectors = [
    '.directory-table.users-list',
    '.directory-table[role="table"]',
    '.directory-table', // Para vista pública
    '.users-list',
    '.admin-users-list',
    '.admin-users table',
    '.admin-users-table table',
    'table.admin-users-table',
    'table.admin-users',
    'table.users-table'
  ];

  for (const selector of selectors) {
    try {
      const element = document.querySelector(selector);
      if (element) {
        console.log(`Tabla encontrada con selector: ${selector}`);
        return element;
      }
    } catch (e) {
      // Ignorar errores de selectores inválidos
    }
  }

  // Si no se encuentra con selectores específicos, buscar por contenido
  const allTables = document.querySelectorAll('[role="table"], table');
  for (const table of allTables) {
    const headers = table.querySelectorAll('[role="columnheader"], th');
    let hasUsername = false;
    let hasEmail = false;
    
    for (const header of headers) {
      const text = header.textContent.toLowerCase();
      if (text.includes('username') || text.includes('name')) {
        hasUsername = true;
      }
      if (text.includes('email')) {
        hasEmail = true;
      }
    }
    
    if (hasUsername && hasEmail) {
      console.log('Tabla encontrada por contenido (username + email)');
      return table;
    }
  }

  return null;
}

// Función para analizar la estructura de la tabla encontrada
function analyzeTableStructure(table) {
  // Verificar si es una tabla moderna de Discourse (CSS Grid + ARIA)
  if (table.classList.contains('directory-table') || table.getAttribute('role') === 'table') {
    
    // Buscar encabezados de columna
    const columnHeaders = table.querySelectorAll('.directory-table__column-header, [role="columnheader"]');
    if (columnHeaders.length > 0) {
      
      // Buscar filas de datos
      const dataRows = table.querySelectorAll('.directory-table__row, [role="row"]:not([role="columnheader"])');
      
      return { 
        type: 'modern', 
        table, 
        columnHeaders: Array.from(columnHeaders), 
        dataRows: Array.from(dataRows) 
      };
    }
  }
  
  // Verificar si tiene thead/tbody tradicional
  const thead = table.querySelector('thead');
  const tbody = table.querySelector('tbody');
  
  if (thead && tbody) {
    console.log('Estructura tradicional: thead + tbody');
    return { type: 'traditional', thead, tbody };
  }
  
  // Si no tiene thead/tbody, buscar filas directamente
  const allRows = table.querySelectorAll('tr');
  if (allRows.length > 0) {
    console.log(`Encontradas ${allRows.length} filas en la tabla`);
    
    // La primera fila suele ser el encabezado
    const headerRow = allRows[0];
    const dataRows = Array.from(allRows).slice(1);
    
    console.log('Estructura alternativa: filas directas');
    return { type: 'alternative', headerRow, dataRows, allRows };
  }
  
  // Si no hay filas, buscar en elementos hijos
  const childElements = table.children;

  
  return null;
}

// Función para agregar event listeners de manera compatible
function addEventListenerSafe(element, event, handler) {
  if (element && typeof element.addEventListener === 'function') {
    element.addEventListener(event, handler);
  }
}

// Cache para almacenar las ubicaciones de los usuarios (solo memoria, sin API calls)
const userLocationCache = new Map();

// Sistema de cola para evitar rate limiting
let requestQueue = [];
let isProcessingQueue = false;
let lastRequestTime = 0;
const MIN_REQUEST_INTERVAL = 1000; // 1 segundo entre peticiones

// Variables globales para el manejo de scroll infinito
let currentTable = null;
let currentDataRows = [];
let locationFilter = null;
let filterCounter = null;
let filterSelect = null;

// Cargar cache desde localStorage al iniciar
function loadCacheFromStorage() {
  try {
    const stored = localStorage.getItem('userLocationCache');
    if (stored) {
      const cacheData = JSON.parse(stored);
      Object.entries(cacheData).forEach(([key, value]) => {
        userLocationCache.set(key, value);
      });
      console.log(`Cache cargado: ${userLocationCache.size} ubicaciones`);
    }
  } catch (error) {
    console.log('Error cargando cache desde localStorage:', error);
  }
}

// Guardar cache en localStorage
function saveCacheToStorage() {
  try {
    const cacheData = Object.fromEntries(userLocationCache);
    localStorage.setItem('userLocationCache', JSON.stringify(cacheData));
  } catch (error) {
    console.log('Error guardando cache en localStorage:', error);
  }
}

// Función simplificada para extraer ubicación del usuario
function extractLocationFromDOM(username) {
  // Verificar cache primero
  if (userLocationCache.has(username)) {
    const cachedLocation = userLocationCache.get(username);
    // Solo re-extraer si es "N/A" y queremos intentar de nuevo
    if (cachedLocation === 'N/A') {
      console.log(`Re-extraendo ubicación para usuario ${username} (tenía N/A en cache)`);
    } else {
      return cachedLocation;
    }
  }
  
  console.log(`Extrayendo ubicación para usuario ${username}`);
  let location = 'N/A';
  
  // Estrategia 1: Buscar en el perfil del usuario (más confiable)
  try {
    const userProfileLink = document.querySelector(`a[href="/u/${username}"]`);
    if (userProfileLink) {
      // Buscar en el contexto del enlace del perfil
      const profileContainer = userProfileLink.closest('.user-card, .directory-table__row, tr');
      if (profileContainer) {
        // Buscar texto que parezca una ubicación real
        const locationText = findLocationInProfile(profileContainer, username);
        if (locationText) {
          location = locationText;
          console.log(`Ubicación encontrada en perfil para ${username}: "${location}"`);
        }
      }
    }
  } catch (error) {
    console.log(`Error buscando en perfil de ${username}:`, error);
  }
  
  // Estrategia 2: Buscar en la fila de la tabla (fallback)
  if (location === 'N/A') {
    try {
      const userRow = document.querySelector(`a[href*="/u/${username}"]`)?.closest('.directory-table__row, tr');
      if (userRow) {
        const locationText = findLocationInTableRow(userRow, username);
        if (locationText) {
          location = locationText;
          console.log(`Ubicación encontrada en fila de tabla para ${username}: "${location}"`);
        }
      }
    } catch (error) {
      console.log(`Error buscando en fila de tabla de ${username}:`, error);
    }
  }
  
  // Estrategia 3: Buscar en atributos específicos
  if (location === 'N/A') {
    try {
      const locationText = findLocationInAttributes(username);
      if (locationText) {
        location = locationText;
        console.log(`Ubicación encontrada en atributos para ${username}: "${location}"`);
      }
    } catch (error) {
      console.log(`Error buscando en atributos de ${username}:`, error);
    }
  }
  
  console.log(`Resultado final para usuario ${username}: "${location}"`);
  
  // Guardar en cache
  userLocationCache.set(username, location);
  saveCacheToStorage();
  
  return location;
}

// Función para buscar ubicación en el perfil del usuario
function findLocationInProfile(container, username) {
  // Buscar en elementos que típicamente contienen información de ubicación
  const locationSelectors = [
    '.user-location',
    '.location',
    '.user-info .location',
    '.profile-location',
    '[data-location]',
    '.user-details .location'
  ];
  
  for (const selector of locationSelectors) {
    const element = container.querySelector(selector);
    if (element) {
      const text = element.textContent.trim();
      if (isValidLocationSimple(text)) {
        console.log(`Ubicación encontrada en selector ${selector}: "${text}"`);
        return extractCountryFromLocation(text);
      }
    }
  }
  
  // NO buscar en todo el texto del contenedor ya que captura texto de UI
  // En su lugar, buscar solo en elementos específicos que podrían contener ubicación
  const potentialLocationElements = container.querySelectorAll('span, div, p, td');
  
  for (const element of potentialLocationElements) {
    const text = element.textContent.trim();
    
    // Saltar texto que obviamente no es ubicación
    if (text.length < 3 || 
        text.length > 50 ||
        text === username ||
        text.toLowerCase().includes('last emailed') ||
        text.toLowerCase().includes('read time') ||
        text.toLowerCase().includes('seen') ||
        text.toLowerCase().includes('topics viewed') ||
        text.toLowerCase().includes('posts read') ||
        text.toLowerCase().includes('created') ||
        text.toLowerCase().includes('status') ||
        text.toLowerCase().includes('joined') ||
        text.toLowerCase().includes('posts') ||
        text.toLowerCase().includes('topics') ||
        text.toLowerCase().includes('likes') ||
        text.toLowerCase().includes('active') ||
        text.toLowerCase().includes('admin') ||
        text.toLowerCase().includes('moderator') ||
        text.toLowerCase().includes('user') ||
        text.toLowerCase().includes('member') ||
        text.toLowerCase().includes('online') ||
        text.toLowerCase().includes('offline') ||
        text.toLowerCase().includes('away') ||
        text.includes('@') ||
        text.includes('http') ||
        text.includes('www') ||
        text.match(/^\d+$/) ||
        text.match(/^\d+[a-z]+$/) ||
        text.match(/\d{4}-\d{2}-\d{2}/) ||
        text.match(/\d{2}:\d{2}/)) {
      continue;
    }
    
    if (isValidLocationSimple(text)) {
      console.log(`Ubicación válida encontrada en elemento: "${text}"`);
      return extractCountryFromLocation(text);
    }
  }
  
  return null;
}

// Función para buscar ubicación en la fila de la tabla
function findLocationInTableRow(row, username) {
  // Buscar en celdas específicas que podrían contener ubicación
  const cells = row.querySelectorAll('.directory-table__cell, td');
  
  for (const cell of cells) {
    const text = cell.textContent.trim();
    
    // Saltar celdas que obviamente no contienen ubicación
    if (text === username || 
        text.includes('@') || 
        text.includes('http') || 
        text.includes('www') ||
        text.match(/^\d+$/) || 
        text.match(/^\d+[a-z]+$/) || 
        text.match(/\d{4}-\d{2}-\d{2}/) || 
        text.match(/\d{2}:\d{2}/) ||
        text.match(/^\d+[a-z]+\d+$/) ||
        text.match(/^< \d+[a-z]+$/) ||
        text.match(/^\d+[a-z]+$/) ||
        text.match(/^\d{4} \d{1,2}:\d{2} [ap]m$/) ||
        text.match(/^[A-Za-z]{3} \d{1,2}, \d{4} \d{1,2}:\d{2} [ap]m$/) ||
        text.match(/^[A-Za-z]{3} \d{1,2}, \d{4}$/) ||
        text.match(/^\d{1,2}:\d{2} [ap]m$/) ||
        text.match(/^\d{4}$/) ||
        text.match(/^\d{1,2}:\d{2}$/) ||
        text.match(/^[A-Za-z]{3} \d{1,2}$/) ||
        text.match(/^\d{1,2}\/\d{1,2}\/\d{4}$/) ||
        text.match(/^\d{4}-\d{1,2}-\d{1,2}$/) ||
        // Texto de UI común
        text.toLowerCase().includes('last emailed') ||
        text.toLowerCase().includes('read time') ||
        text.toLowerCase().includes('seen') ||
        text.toLowerCase().includes('topics viewed') ||
        text.toLowerCase().includes('posts read') ||
        text.toLowerCase().includes('created') ||
        text.toLowerCase().includes('status') ||
        text.toLowerCase().includes('joined') ||
        text.toLowerCase().includes('posts') ||
        text.toLowerCase().includes('topics') ||
        text.toLowerCase().includes('likes') ||
        text.toLowerCase().includes('active') ||
        text.toLowerCase().includes('admin') ||
        text.toLowerCase().includes('moderator') ||
        text.toLowerCase().includes('user') ||
        text.toLowerCase().includes('member') ||
        text.toLowerCase().includes('online') ||
        text.toLowerCase().includes('offline') ||
        text.toLowerCase().includes('away')) {
      continue;
    }
    
    if (isValidLocationSimple(text)) {
      console.log(`Ubicación válida encontrada en fila: "${text}"`);
      return extractCountryFromLocation(text);
    }
  }
  
  return null;
}

// Función para buscar ubicación en atributos
function findLocationInAttributes(username) {
  const userRow = document.querySelector(`a[href*="/u/${username}"]`)?.closest('.directory-table__row, tr');
  if (!userRow) return null;
  
  const elements = userRow.querySelectorAll('*');
  
  for (const element of elements) {
    // Buscar en atributos title
    const title = element.getAttribute('title');
    if (title && isValidLocationSimple(title)) {
      return extractCountryFromLocation(title);
    }
    
    // Buscar en atributos data-*
    const attributes = element.attributes;
    for (const attr of attributes) {
      if (attr.name.startsWith('data-') && attr.value && isValidLocationSimple(attr.value)) {
        return extractCountryFromLocation(attr.value);
      }
    }
  }
  
  return null;
}

// Función para obtener ubicación desde el perfil del usuario
async function getUserLocation(username) {
  // Primero intentar extraer del DOM
  const domLocation = extractLocationFromDOM(username);
  
  // Si no se encuentra en el DOM, intentar desde el perfil
  if (domLocation === 'N/A') {
    console.log(`Ubicación no encontrada en DOM para ${username}, intentando desde perfil...`);
    try {
      const profileLocation = await extractLocationFromProfile(username);
      if (profileLocation && profileLocation !== 'N/A') {
        console.log(`Ubicación encontrada en perfil para ${username}: "${profileLocation}"`);
        return profileLocation;
      }
    } catch (error) {
      console.log(`Error obteniendo ubicación desde perfil para ${username}:`, error);
    }
  }
  
  return domLocation;
}

// Función para agregar una petición a la cola
function queueProfileRequest(username, resolve, reject) {
  requestQueue.push({ username, resolve, reject });
  console.log(`Petición agregada a la cola para ${username}. Cola: ${requestQueue.length}`);
  
  // Iniciar procesamiento si no está en curso
  if (!isProcessingQueue) {
    processRequestQueue();
  }
}

// Función para procesar la cola de peticiones
async function processRequestQueue() {
  if (isProcessingQueue || requestQueue.length === 0) {
    return;
  }
  
  isProcessingQueue = true;
  console.log(`Procesando cola de peticiones. Pendientes: ${requestQueue.length}`);
  
  while (requestQueue.length > 0) {
    const { username, resolve, reject } = requestQueue.shift();
    
    try {
      // Calcular delay para evitar rate limiting
      const now = Date.now();
      const timeSinceLastRequest = now - lastRequestTime;
      
      if (timeSinceLastRequest < MIN_REQUEST_INTERVAL) {
        const delay = MIN_REQUEST_INTERVAL - timeSinceLastRequest;
        console.log(`Esperando ${delay}ms antes de la siguiente petición para ${username}`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
      
      console.log(`Procesando petición para ${username}`);
      const location = await fetchUserProfile(username);
      lastRequestTime = Date.now();
      
      // Guardar en cache
      userLocationCache.set(username, location);
      saveCacheToStorage();
      
      resolve(location);
      
    } catch (error) {
      console.log(`Error procesando petición para ${username}:`, error);
      reject(error);
    }
  }
  
  isProcessingQueue = false;
  console.log('Cola de peticiones procesada completamente');
}

// Función para hacer la petición al perfil del usuario
async function fetchUserProfile(username) {
  try {
    // Hacer una llamada al perfil del usuario
    const response = await fetch(`/u/${username}.json`);
    if (!response.ok) {
      console.log(`Error en respuesta del perfil para ${username}: ${response.status}`);
      return 'N/A';
    }
    
    const userData = await response.json();
    console.log(`Datos del perfil para ${username}:`, userData);
    
    // Buscar la ubicación en los datos del usuario
    if (userData.user && userData.user.location) {
      const location = userData.user.location;
      console.log(`Ubicación encontrada en perfil para ${username}: "${location}"`);
      return extractCountryFromLocation(location);
    }
    
    console.log(`No se encontró ubicación en perfil para ${username}`);
    return 'N/A';
    
  } catch (error) {
    console.log(`Error en fetch del perfil para ${username}:`, error);
    return 'N/A';
  }
}

// Función para extraer ubicación desde el perfil del usuario (ahora usa cola)
function extractLocationFromProfile(username) {
  return new Promise((resolve, reject) => {
    queueProfileRequest(username, resolve, reject);
  });
}

// Función para procesar nuevas filas que se agreguen dinámicamente
function processNewRows() {
  if (!currentTable) return;
  
  const allRows = currentTable.querySelectorAll('.directory-table__row, tr');
  const newRows = [];
  
  // Encontrar filas que no tienen la columna de ubicación
  allRows.forEach(row => {
    if (!row.querySelector('.location-column-data')) {
      newRows.push(row);
    }
  });
  
  if (newRows.length > 0) {
    console.log(`Procesando ${newRows.length} nuevas filas del scroll infinito`);
    
    // Procesar las nuevas filas con delay para asegurar que el DOM esté renderizado
    setTimeout(async () => {
      for (let index = 0; index < newRows.length; index++) {
        const row = newRows[index];
        // Procesar con delay escalonado para evitar problemas de rendimiento
        setTimeout(async () => {
          await addLocationCellToModernRow(row);
        }, index * 100); // 100ms entre cada fila para scroll infinito
      }
      
      // Actualizar después de un delay adicional
      setTimeout(() => {
        currentDataRows = Array.from(currentTable.querySelectorAll('.directory-table__row, tr'));
        updateFilterAndCounter();
        console.log(`Scroll infinito: ${newRows.length} nuevas filas procesadas, total: ${currentDataRows.length}`);
        
        // Asegurar que el filtro se aplique a las nuevas filas
        if (filterSelect && filterSelect.value && filterSelect.value !== 'all') {
          console.log(`Aplicando filtro "${filterSelect.value}" a las nuevas filas`);
          filterByLocation(filterSelect.value);
        }
      }, newRows.length * 100 + 200);
    }, 300); // Esperar 300ms antes de procesar
  }
}

// Función para procesar todas las filas de la tabla (para carga inicial)
function processAllRows() {
  if (!currentTable) return;
  
  const allRows = currentTable.querySelectorAll('.directory-table__row, tr');
  console.log(`Procesando ${allRows.length} filas de la tabla actual`);
  
  // Procesar todas las filas
  allRows.forEach((row, index) => {
    // Procesar con delay escalonado para evitar problemas de rendimiento
    setTimeout(async () => {
      await addLocationCellToModernRow(row);
    }, index * 10); // 10ms entre cada fila (más rápido para carga inicial)
  });
  
  // Actualizar después de un delay
  setTimeout(() => {
    currentDataRows = Array.from(currentTable.querySelectorAll('.directory-table__row, tr'));
    updateFilterAndCounter();
  }, allRows.length * 10 + 100);
}

// Función para actualizar el filtro y contador
function updateFilterAndCounter() {
  if (!currentTable || !filterCounter || !filterSelect) return;
  
  // Actualizar contador
  const visibleRows = currentTable.querySelectorAll('.directory-table__row:not([style*="display: none"])');
  const totalRows = currentDataRows.length;
  filterCounter.textContent = `${visibleRows.length} of ${totalRows} users`;
  
  // Actualizar opciones del filtro
  updateLocationOptions();
  
  // Reaplicar el filtro actual si hay uno seleccionado
  const currentFilter = filterSelect.value;
  if (currentFilter && currentFilter !== 'all') {
    console.log(`Reaplicando filtro "${currentFilter}" después de actualizar filas`);
    filterByLocation(currentFilter);
  }
}

// Función para actualizar opciones del filtro
function updateLocationOptions() {
  if (!currentTable || !filterSelect) return;
  
  const locations = new Set();
  const locationCells = currentTable.querySelectorAll('.location-column-data');
  
  locationCells.forEach(cell => {
    const location = cell.textContent.trim();
    if (location && location !== 'N/A' && location !== 'Sin ubicación') {
      locations.add(location);
    }
  });
  
  // Limpiar opciones existentes (excepto las primeras dos)
  while (filterSelect.children.length > 2) {
    filterSelect.removeChild(filterSelect.lastChild);
  }
  
  // Agregar opciones de ubicaciones
  const sortedLocations = Array.from(locations).sort();
  sortedLocations.forEach(location => {
    const option = document.createElement('option');
    option.value = location;
    option.textContent = location;
    filterSelect.appendChild(option);
  });
}

// Función para configurar scroll infinito mejorado
function setupInfiniteScrollObserver() {
  if (!currentTable) return;
  
  console.log('Configurando scroll infinito mejorado');
  
  let processingTimeout = null;
  let isProcessing = false;
  let lastRowCount = 0;
  
  // Crear un observer para detectar cambios en el DOM
  const observer = new MutationObserver(function(mutations) {
    let shouldProcess = false;
    
    mutations.forEach(function(mutation) {
      // Verificar si se agregaron nuevos nodos
      if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
        mutation.addedNodes.forEach(function(node) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            // Verificar si es una fila de tabla o contiene filas
            if (node.classList && (node.classList.contains('directory-table__row') || node.querySelector('.directory-table__row'))) {
              shouldProcess = true;
            }
          }
        });
      }
    });
    
    if (shouldProcess && !isProcessing) {
      // Limpiar timeout anterior si existe
      if (processingTimeout) {
        clearTimeout(processingTimeout);
      }
      
      // Usar setTimeout con delay más largo para asegurar que el DOM esté completamente renderizado
      processingTimeout = setTimeout(() => {
        const currentRowCount = currentTable.querySelectorAll('.directory-table__row, tr').length;
        if (currentRowCount > lastRowCount) {
          console.log(`Scroll infinito detectado: ${lastRowCount} → ${currentRowCount} filas, procesando nuevas filas...`);
          lastRowCount = currentRowCount;
          processNewRows();
        }
      }, 1500); // Aumentar a 1.5 segundos para asegurar renderizado completo
    }
  });
  
  // Observar cambios en el contenedor de la tabla
  const tableContainer = currentTable.parentNode;
  if (tableContainer) {
    observer.observe(tableContainer, {
      childList: true,
      subtree: true
    });
  }
  
  // También observar cambios directamente en la tabla
  observer.observe(currentTable, {
    childList: true,
    subtree: true
  });
  
  // Inicializar el contador de filas
  lastRowCount = currentTable.querySelectorAll('.directory-table__row, tr').length;
  
  console.log(`MutationObserver configurado para scroll infinito mejorado con delay de 1.5 segundos (${lastRowCount} filas iniciales)`);
}


// Función para configurar manejadores de navegación
function setupNavigationHandlers() {
  console.log('Configurando manejadores de navegación para scroll infinito');
  
  // Ejecutar cuando cambia la URL (navegación SPA de Discourse)
  let currentUrl = window.location.href;
  const observer = new MutationObserver(function() {
    if (window.location.href !== currentUrl) {
      currentUrl = window.location.href;
      
      console.log('Cambio de URL detectado, reinicializando columna de ubicación...');
      
      // Limpiar columna anterior
      cleanupLocationColumn();
      
      // Agregar nueva columna
      setTimeout(addLocationColumn, 1000);
    }
  });
  
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
  
  // También ejecutar cuando se hace clic en enlaces de navegación
  document.addEventListener('click', function(event) {
    const target = event.target.closest('a');
    if (target && target.href) {
      const href = target.href;
      const isAdminUsersLink = href.includes('/admin/users/list/');
      const isPublicUsersLink = href.includes('/u') && (href.includes('order=') || href.endsWith('/u'));
      
      if (isAdminUsersLink || isPublicUsersLink) {
        console.log('Navegación de usuarios detectada, reinicializando...');
        setTimeout(() => {
          cleanupLocationColumn();
          addLocationColumn();
        }, 1000);
      }
    }
  });
}

// Inicializar cache al cargar
loadCacheFromStorage();
// Limpiar cache de entradas problemáticas
cleanInvalidCacheEntries();
cleanDateTimeCacheEntries();

// Función simplificada para validar ubicaciones
function isValidLocationSimple(text) {
  if (!text || text.length < 2 || text.length > 50) {
    return false;
  }
  
  const lowerText = text.toLowerCase();
  
  // Rechazar específicamente texto de UI común
  const uiTexts = [
    'last emailed', 'read time', 'seen', 'topics viewed', 'posts read',
    'created', 'status', 'joined', 'posts', 'topics', 'likes', 'active',
    'admin', 'moderator', 'user', 'member', 'online', 'offline', 'away',
    'busy', 'do not disturb', 'profile', 'avatar', 'email', 'username',
    'name', 'title', 'role', 'permissions', 'settings', 'preferences',
    'account', 'login', 'logout', 'search', 'filter', 'sort', 'order',
    'date', 'updated', 'deleted', 'archived', 'hidden', 'private', 'public',
    'draft', 'published', 'pending', 'approved', 'rejected', 'flagged',
    'reported', 'banned', 'muted', 'warned', 'restricted', 'limited',
    'days', 'hours', 'minutes', 'seconds', 'ago', 'today', 'yesterday',
    'week', 'month', 'year', 'january', 'february', 'march', 'april',
    'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december',
    'am', 'pm', 'morning', 'afternoon', 'evening', 'night', 'midnight', 'noon'
  ];
  
  // Verificar si contiene texto de UI
  for (const uiText of uiTexts) {
    if (lowerText === uiText || lowerText.includes(uiText)) {
      console.log(`Texto rechazado por ser UI: "${text}" (contiene: "${uiText}")`);
      return false;
    }
  }
  
  // Lista de países comunes (expandible)
  const commonCountries = [
    'Spain', 'Italy', 'France', 'Germany', 'United Kingdom', 'Portugal', 'Netherlands',
    'Belgium', 'Austria', 'Switzerland', 'Sweden', 'Norway', 'Denmark', 'Finland',
    'Poland', 'Czech Republic', 'Hungary', 'Romania', 'Bulgaria', 'Greece', 'Turkey',
    'United States', 'Canada', 'Mexico', 'Brazil', 'Argentina', 'Chile', 'Colombia',
    'Australia', 'New Zealand', 'Japan', 'China', 'India', 'South Korea', 'Thailand',
    'South Africa', 'Egypt', 'Morocco', 'Tunisia', 'Algeria', 'Libya', 'Nigeria',
    'Kenya', 'Ghana', 'Senegal', 'Ivory Coast', 'Mali', 'Burkina Faso', 'Niger',
    'Chad', 'Sudan', 'Ethiopia', 'Somalia', 'Uganda', 'Tanzania', 'Rwanda',
    'Burundi', 'Democratic Republic of Congo', 'Republic of Congo', 'Cameroon',
    'Central African Republic', 'Equatorial Guinea', 'Gabon', 'São Tomé and Príncipe',
    'Angola', 'Zambia', 'Zimbabwe', 'Botswana', 'Namibia', 'Lesotho', 'Swaziland',
    'Mozambique', 'Madagascar', 'Mauritius', 'Seychelles', 'Comoros', 'Djibouti',
    'Eritrea', 'Somaliland', 'Western Sahara', 'Cape Verde', 'Guinea-Bissau',
    'Guinea', 'Sierra Leone', 'Liberia', 'Gambia', 'Mauritania', 'Albania',
    'Bosnia and Herzegovina', 'Croatia', 'Serbia', 'Montenegro', 'North Macedonia',
    'Kosovo', 'Slovenia', 'Slovakia', 'Lithuania', 'Latvia', 'Estonia', 'Belarus',
    'Ukraine', 'Moldova', 'Russia', 'Kazakhstan', 'Uzbekistan', 'Turkmenistan',
    'Tajikistan', 'Kyrgyzstan', 'Afghanistan', 'Pakistan', 'Bangladesh', 'Sri Lanka',
    'Maldives', 'Nepal', 'Bhutan', 'Myanmar', 'Laos', 'Cambodia', 'Vietnam',
    'Malaysia', 'Singapore', 'Indonesia', 'Philippines', 'Brunei', 'East Timor',
    'Papua New Guinea', 'Solomon Islands', 'Vanuatu', 'Fiji', 'Samoa', 'Tonga',
    'Palau', 'Marshall Islands', 'Micronesia', 'Nauru', 'Kiribati', 'Tuvalu',
    'Monaco', 'San Marino', 'Vatican City', 'Liechtenstein', 'Andorra', 'Malta',
    'Cyprus', 'Iceland', 'Luxembourg', 'Ireland', 'Israel', 'Palestine', 'Jordan',
    'Lebanon', 'Syria', 'Iraq', 'Iran', 'Saudi Arabia', 'Yemen', 'Oman', 'UAE',
    'Qatar', 'Bahrain', 'Kuwait', 'Iraq', 'Afghanistan', 'Uzbekistan', 'Tajikistan'
  ];
  
  // Verificar si es un país conocido
  for (const country of commonCountries) {
    if (lowerText === country.toLowerCase() || lowerText.includes(country.toLowerCase())) {
      console.log(`País conocido encontrado: "${text}"`);
      return true;
    }
  }
  
  // Rechazar usernames comunes (patrones típicos de usernames)
  if (text.match(/^[a-z]+_[a-z]+$/) || // patrones como "zonas_comunes"
      text.match(/^[a-z]+\.[a-z]+$/) || // patrones como "user.name"
      text.match(/^[a-z]+[0-9]+$/) || // patrones como "user123"
      text.match(/^[a-z]+[0-9]+[a-z]+$/) || // patrones como "user123name"
      text.match(/^[a-z]+[0-9]+_[a-z]+$/) || // patrones como "user123_name"
      text.match(/^[a-z]+_[a-z]+[0-9]+$/) || // patrones como "user_name123"
      text.match(/^[a-z]+_[a-z]+_[a-z]+$/)) { // patrones como "user_name_more"
    console.log(`Texto rechazado por ser username: "${text}"`);
    return false;
  }
  
  // Rechazar texto que no empieza con mayúscula
  if (text.match(/^[a-z]/)) {
    console.log(`Texto rechazado por no tener mayúscula: "${text}"`);
    return false;
  }
  
  // Verificar patrones básicos de ubicación
  // Debe empezar con mayúscula y contener solo letras, espacios, comas y puntos
  if (text.match(/^[A-Z][a-zA-Z\s,.-]+$/) && 
      text.length >= 3 && 
      text.length <= 30 &&
      !text.match(/\d/) && // No debe contener números
      !text.includes('@') && // No debe contener @
      !text.includes('http') && // No debe contener http
      !text.includes('www') && // No debe contener www
      !text.match(/^\d+/) && // No debe empezar con número
      !text.match(/[ap]m$/) && // No debe terminar en am/pm
      !text.match(/\d{4}/) && // No debe contener años
      !text.match(/\d{1,2}:\d{2}/) && // No debe contener horas
      !text.match(/^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i) && // No debe empezar con mes
      !text.match(/(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i) && // No días de la semana
      !text.match(/(today|yesterday|tomorrow)/i)) { // No palabras temporales
    console.log(`Patrón de ubicación válido: "${text}"`);
    return true;
  }
  
  console.log(`Texto rechazado por no cumplir criterios: "${text}"`);
  return false;
}

// Función legacy para mantener compatibilidad
function isValidLocation(text) {
  return isValidLocationSimple(text);
}

// Función simplificada para extraer el país de la ubicación
function extractCountryFromLocation(location) {
  if (!location || location === 'N/A') {
    return 'N/A';
  }

  // Limpiar y normalizar el texto
  const cleanLocation = location.trim();

  // Si la ubicación contiene una coma, tomar la última parte (país)
  if (cleanLocation.includes(',')) {
    const parts = cleanLocation.split(',');
    const country = parts[parts.length - 1].trim();
    return country || 'N/A';
  }

  // Si no hay coma, asumir que es solo el país
  return cleanLocation;
}

// Función para agregar la columna Location
async function addLocationColumn() {
  try {
    // Verificar si estamos en una página de usuarios (admin o pública)
    const isAdminUsersPage = window.location.pathname.includes('/admin/users/list/');
    const isPublicUsersPage = window.location.pathname.includes('/u') && 
      (window.location.search.includes('order=') || window.location.pathname === '/u');
    
    if (!isAdminUsersPage && !isPublicUsersPage) {
      return;
    }
    
    // Esperar un poco más para que la página se cargue completamente
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Buscar la tabla usando nuestra función personalizada
    const table = findUsersTable();
    if (!table) {
      // Intentar de nuevo en unos segundos
      setTimeout(addLocationColumn, 3000);
      return;
    }
    
    // Analizar la estructura de la tabla
    const structure = analyzeTableStructure(table);
    if (!structure) {
      return;
    }
    
    // Verificar si ya se agregó la columna
    if (table.querySelector('.location-column-header')) {
      return;
    }
    
    if (structure.type === 'modern') {
      // Estructura moderna de Discourse (CSS Grid + ARIA)
      addColumnToModernTable(structure.table, structure.columnHeaders, structure.dataRows);
    } else if (structure.type === 'traditional') {
      // Estructura tradicional con thead/tbody
      addColumnToTraditionalTable(structure.thead, structure.tbody);
    } else if (structure.type === 'alternative') {
      // Estructura alternativa con filas directas
      addColumnToAlternativeTable(structure.headerRow, structure.dataRows);
    }
    
    // Aplicar estilos CSS personalizados
    applyLocationColumnStyles();
    
  } catch (error) {
    // Intentar de nuevo en unos segundos
    setTimeout(addLocationColumn, 3000);
  }
}

// Función para agregar columna a tabla moderna de Discourse
function addColumnToModernTable(table, columnHeaders, dataRows) {
  // Guardar referencias globales para el manejo de scroll infinito
  currentTable = table;
  currentDataRows = dataRows;
  
  // Crear encabezado de columna
  const locationHeader = document.createElement('div');
  locationHeader.className = 'directory-table__column-header location-column-header sortable';
  locationHeader.setAttribute('aria-sort', 'none');
  locationHeader.setAttribute('role', 'columnheader');
  
  const headerContents = document.createElement('div');
  headerContents.className = 'header-contents';
  headerContents.setAttribute('role', 'button');
  headerContents.setAttribute('tabindex', '0');
  headerContents.setAttribute('aria-label', 'Location');
  headerContents.setAttribute('aria-pressed', 'false');
  
  const textSpan = document.createElement('span');
  textSpan.className = 'text';
  textSpan.textContent = 'Location';
  
  headerContents.appendChild(textSpan);
  locationHeader.appendChild(headerContents);
  
  // Insertar el encabezado antes del último encabezado existente
  if (columnHeaders.length > 0) {
    const lastHeader = columnHeaders[columnHeaders.length - 1];
    lastHeader.parentNode.insertBefore(locationHeader, lastHeader.nextSibling);
  } else {
    // Si no hay encabezados, insertar en el contenedor de encabezados
    const headerContainer = table.querySelector('.directory-table__header');
    if (headerContainer) {
      headerContainer.appendChild(locationHeader);
    }
  }
  
  // Agregar celdas de datos usando el nuevo enfoque
  processAllRows();
  
  // Actualizar el CSS Grid para incluir la nueva columna
  updateGridColumns(table);
  
  // Agregar filtro por ubicación
  addLocationFilter(table, dataRows);
}

// Función para agregar celda de ubicación a una fila moderna
async function addLocationCellToModernRow(row) {
  const locationCell = document.createElement('div');
  locationCell.className = 'directory-table__cell location-column-data';
  locationCell.setAttribute('role', 'cell');
  
  // Obtener el username de la fila
  const usernameCell = row.querySelector('.directory-table__cell.username');
  let username = '';
  
  if (usernameCell) {
    // Buscar el enlace del username (el segundo enlace con clase ember-view)
    const usernameLink = usernameCell.querySelector('a.ember-view');
    
    if (usernameLink) {
      username = usernameLink.textContent.trim();
    } else {
      // Intentar otros selectores para la vista pública
      const avatarLink = usernameCell.querySelector('a.avatar');
      if (avatarLink) {
        const href = avatarLink.getAttribute('href');
        if (href && href.startsWith('/u/')) {
          username = href.split('/u/')[1];
        }
      }
      
      if (!username) {
        username = usernameCell.textContent.trim();
      }
    }
  } else {
    // Intentar otros selectores para la vista pública
    const allCells = row.querySelectorAll('.directory-table__cell');
    
    for (const cell of allCells) {
      const links = cell.querySelectorAll('a');
      for (const link of links) {
        const href = link.getAttribute('href');
        if (href && href.startsWith('/u/')) {
          username = href.split('/u/')[1];
          break;
        }
      }
      if (username) break;
    }
  }
  
  if (username) {
    try {
      // Obtener ubicación (ahora async)
      const location = await getUserLocation(username);
      
      locationCell.textContent = location;
      locationCell.style.fontStyle = 'normal';
      locationCell.style.color = '#40312a';
      locationCell.style.fontSize = '0.9em';
        
        // Aplicar estilos especiales para ubicaciones válidas
      if (location !== 'N/A' && location !== 'Sin ubicación') {
          locationCell.style.fontWeight = '500';
          locationCell.style.color = '#8A4A19';
      } else {
        locationCell.style.color = '#999';
        locationCell.style.fontStyle = 'italic';
        }
    } catch (error) {
      console.log(`Error obteniendo ubicación para ${username}:`, error);
      locationCell.textContent = 'N/A';
      locationCell.style.color = '#999';
      locationCell.style.fontStyle = 'italic';
    }
  } else {
    locationCell.textContent = 'N/A';
    locationCell.style.color = '#999';
    locationCell.style.fontStyle = 'italic';
  }
  
  // Insertar la celda en la posición correcta
  const lastCell = row.querySelector('.directory-table__cell:last-child');
  if (lastCell) {
    row.insertBefore(locationCell, lastCell.nextSibling);
  } else {
    row.appendChild(locationCell);
  }
}

// Función para actualizar las columnas del CSS Grid
function updateGridColumns(table) {
  const currentStyle = table.style.gridTemplateColumns;
  if (currentStyle) {
    // Agregar una columna más al grid
    const newStyle = currentStyle.replace(/\)$/, ' minmax(min-content, 1fr))');
    table.style.gridTemplateColumns = newStyle;
    console.log('CSS Grid actualizado para incluir la nueva columna');
  }
}

// Función para agregar filtro por ubicación
function addLocationFilter(table, dataRows) {
  console.log('Agregando filtro por ubicación...');
  
  // Crear el contenedor del filtro
  const filterContainer = document.createElement('div');
  filterContainer.className = 'location-filter-container';
  filterContainer.style.cssText = `
    margin: 10px 0;
    padding: 10px;
    background-color: var(--bg-tertiary);
    border: 1px solid var(--border-primary);
    border-radius: 4px;
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
  `;
  
  // Crear etiqueta
  const label = document.createElement('label');
  label.textContent = 'Filter by Location:';
  label.style.cssText = `
    font-weight: 600;
    color: var(--text-primary);
    margin-right: 5px;
  `;
  
  // Crear dropdown
  const select = document.createElement('select');
  select.className = 'location-filter-select';
  select.style.cssText = `
    padding: 5px 10px;
    border: 1px solid #e0c052;
    border-radius: 4px;
    background-color: var(--bg-primary);
    color: var(--text-primary);
    font-size: 14px;
    min-width: 150px;
  `;
  
  // Agregar opciones iniciales
  const allOption = document.createElement('option');
  allOption.value = 'all';
  allOption.textContent = 'All users';
  select.appendChild(allOption);
  
  const noLocationOption = document.createElement('option');
  noLocationOption.value = 'no-location';
  noLocationOption.textContent = 'No location';
  select.appendChild(noLocationOption);
  
  // Crear contador
  const counter = document.createElement('span');
  counter.className = 'location-filter-counter';
  counter.style.cssText = `
    color: var(--text-secondary);
    font-weight: 500;
    font-size: 14px;
  `;
  
  // Guardar referencias globales
  filterCounter = counter;
  filterSelect = select;
  
  // Función para actualizar el contador
  function updateCounter() {
    const visibleRows = table.querySelectorAll('.directory-table__row:not([style*="display: none"])');
    const totalRows = currentDataRows.length;
    counter.textContent = `${visibleRows.length} of ${totalRows} users`;
  }
  
  // Función para filtrar
  function filterByLocation(selectedLocation) {
    console.log(`Filtrando por ubicación: "${selectedLocation}"`);
    
    // Usar currentDataRows que se actualiza con scroll infinito, no dataRows inicial
    const rowsToFilter = currentDataRows.length > 0 ? currentDataRows : dataRows;
    console.log(`Filtrando ${rowsToFilter.length} filas (currentDataRows: ${currentDataRows.length}, dataRows: ${dataRows.length})`);
    
    let visibleCount = 0;
    
    rowsToFilter.forEach((row, index) => {
      const locationCell = row.querySelector('.location-column-data');
      let shouldShow = false;
      let cellLocation = 'N/A';
      
      if (locationCell) {
        cellLocation = locationCell.textContent.trim();
        
        if (selectedLocation === 'all') {
          shouldShow = true;
        } else if (selectedLocation === 'no-location') {
          shouldShow = (cellLocation === 'N/A' || cellLocation === 'Sin ubicación' || cellLocation === '...');
        } else {
          // Comparación más robusta para ubicaciones
          const cellLocationLower = cellLocation.toLowerCase();
          const selectedLocationLower = selectedLocation.toLowerCase();
          
          // Comparación exacta (prioridad máxima)
          shouldShow = (cellLocationLower === selectedLocationLower);
          
          // Si no coincide exactamente, verificar si contiene la ubicación seleccionada
          if (!shouldShow && cellLocationLower.includes(selectedLocationLower)) {
            shouldShow = true;
          }
          
          // Verificar casos especiales con matching más estricto
          if (!shouldShow) {
            const cellWords = cellLocationLower.split(/[\s,.-]+/).filter(word => word.length > 2);
            const selectedWords = selectedLocationLower.split(/[\s,.-]+/).filter(word => word.length > 2);
            
            // Solo hacer matching si hay al menos 2 palabras en común (para evitar falsos positivos)
            if (selectedWords.length >= 2) {
              const commonWords = selectedWords.filter(selectedWord => 
                cellWords.some(cellWord => cellWord === selectedWord)
              );
              shouldShow = commonWords.length >= 2;
            } else if (selectedWords.length === 1) {
              // Para países de una palabra, usar matching exacto de palabra completa
              shouldShow = cellWords.some(cellWord => cellWord === selectedWords[0]);
            }
          }
        }
      } else {
        // Si no hay celda de ubicación, tratar como "no-location"
        if (selectedLocation === 'all') {
          shouldShow = true;
        } else if (selectedLocation === 'no-location') {
          shouldShow = true;
        } else {
          shouldShow = false;
        }
        cellLocation = 'N/A (sin columna)';
      }
      
      row.style.display = shouldShow ? '' : 'none';
      if (shouldShow) visibleCount++;
      
      // Debug para las primeras filas
      if (index < 5) {
        console.log(`Fila ${index}: "${cellLocation}" ${shouldShow ? 'VISIBLE' : 'OCULTA'} (filtro: "${selectedLocation}")`);
      }
    });
    
    console.log(`Filtro aplicado: ${visibleCount} usuarios visibles de ${rowsToFilter.length} total`);
    updateCounter();
  }
  
  // Event listener para el filtro
  select.addEventListener('change', (e) => {
    filterByLocation(e.target.value);
  });
  
  // Función para forzar la reaplicación del filtro (útil para debugging)
  window.forceFilterReapply = function() {
    if (filterSelect && filterSelect.value) {
      console.log('Forzando reaplicación del filtro...');
      filterByLocation(filterSelect.value);
    }
  };
  
  // Ensamblar el filtro
  filterContainer.appendChild(label);
  filterContainer.appendChild(select);
  filterContainer.appendChild(counter);
  
  // Insertar el filtro antes de la tabla
  const tableContainer = table.closest('.directory-table-container') || table.parentNode;
  if (tableContainer) {
    tableContainer.insertBefore(filterContainer, table);
  }
  
  // Actualizar contador inicial
  updateCounter();
  
  // Actualizar opciones inmediatamente (ya que no hay API calls)
  updateLocationOptions();
  
  // Configurar scroll infinito mejorado
  setupInfiniteScrollObserver();
  
  console.log('Filtro por ubicación agregado exitosamente');
}

// Función para agregar columna a tabla tradicional
function addColumnToTraditionalTable(thead, tbody) {
  const headerRow = thead.querySelector('tr');
  if (!headerRow) return;
  
  // Agregar encabezado de columna
  const locationHeader = document.createElement('th');
  locationHeader.className = 'location-column-header';
  locationHeader.textContent = 'Location';
  locationHeader.style.minWidth = '120px';
  locationHeader.style.textAlign = 'center';
  
  // Insertar antes de la última columna
  const lastHeader = headerRow.querySelector('th:last-child');
  if (lastHeader) {
    headerRow.insertBefore(locationHeader, lastHeader);
  } else {
    headerRow.appendChild(locationHeader);
  }
  
  // Agregar celdas de datos
  const rows = tbody.querySelectorAll('tr');
  console.log(`Agregando celdas para ${rows.length} filas...`);
  
  for (const row of rows) {
    addLocationCellToRow(row);
  }
}

// Función para agregar columna a tabla alternativa
function addColumnToAlternativeTable(headerRow, dataRows) {
  // Agregar encabezado de columna
  const locationHeader = document.createElement('th');
  locationHeader.className = 'location-column-header';
  locationHeader.textContent = 'Location';
  locationHeader.style.minWidth = '120px';
  locationHeader.style.textAlign = 'center';
  
  // Insertar antes de la última columna
  const lastHeader = headerRow.querySelector('th:last-child');
  if (lastHeader) {
    headerRow.insertBefore(locationHeader, lastHeader);
  } else {
    headerRow.appendChild(locationHeader);
  }
  
  // Agregar celdas de datos
  console.log(`Agregando celdas para ${dataRows.length} filas...`);
  
  for (const row of dataRows) {
    addLocationCellToRow(row);
  }
}

// Función para agregar celda de ubicación a una fila tradicional
function addLocationCellToRow(row) {
  const locationCell = document.createElement('td');
  locationCell.className = 'location-column-data';
  locationCell.style.textAlign = 'center';
  locationCell.style.verticalAlign = 'middle';
  
  // Obtener el username de la fila
  const usernameLink = row.querySelector('td:first-child a');
  if (usernameLink) {
    const username = usernameLink.textContent.trim();
    
    // Obtener ubicación directamente del DOM (sin API calls)
    const location = getUserLocation(username);
    
      locationCell.textContent = location;
      locationCell.style.fontStyle = 'normal';
      locationCell.style.color = '#40312a';
    locationCell.style.fontSize = '0.9em';
      
      // Aplicar estilos especiales para ubicaciones válidas
    if (location !== 'N/A' && location !== 'Sin ubicación') {
        locationCell.style.fontWeight = '500';
        locationCell.style.color = '#8A4A19';
    } else {
      locationCell.style.color = '#999';
      locationCell.style.fontStyle = 'italic';
      }
  } else {
    locationCell.textContent = 'N/A';
    locationCell.style.color = '#999';
    locationCell.style.fontStyle = 'italic';
  }
  
  // Insertar la celda en la posición correcta
  const lastCell = row.querySelector('td:last-child');
  if (lastCell) {
    row.insertBefore(locationCell, lastCell);
  } else {
    row.appendChild(locationCell);
  }
}

// Función para aplicar estilos CSS del footer
function applyFooterStyles() {
  const style = document.createElement('style');
  style.setAttribute('data-footer-css', 'true');
  style.textContent = `
    /* Estilos para el footer personalizado de Youth Care Assembly */
    .yc-footer-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px 15px;
    }

    .yc-footer-divider {
      border: none;
      height: 1px;
      background-color: var(--border-secondary);
      margin: 0 0 30px 0;
    }

    .yc-footer-row {
      margin-bottom: 20px;
    }

    .yc-footer-logos {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 20px;
    }

    .yc-footer-logo {
      display: inline-block;
      transition: transform 0.3s ease, opacity 0.3s ease;
      text-decoration: none;
    }

    .yc-footer-logo:hover {
      transform: scale(1.05);
      opacity: 0.8;
    }

    .yc-footer-logo img {
      max-height: 60px;
      max-width: 120px;
      width: auto;
      height: auto;
      object-fit: contain;
      filter: grayscale(20%);
      transition: filter 0.3s ease;
    }

    .yc-footer-logo:hover img {
      filter: grayscale(0%);
    }

    /* Fila de información de la UE */
    .yc-footer-eu-row {
      margin-top: 30px;
      padding-top: 20px;
    }

    .yc-footer-eu-content {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 30px;
      flex-wrap: wrap;
    }

    .yc-footer-eu-logo {
      flex-shrink: 0;
    }

    .yc-footer-eu-logo img {
      max-height: 80px;
      max-width: 200px;
      width: auto;
      height: auto;
      object-fit: contain;
    }

    .yc-footer-eu-text {
      flex: 1;
      min-width: 300px;
      max-width: 600px;
    }

    .yc-footer-eu-text p {
      font-size: 10pt;
      font-family: Arial, sans-serif;
      color: var(--text-secondary);
      line-height: 1.4;
      margin: 0;
      text-align: center;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .yc-footer-container {
        padding: 15px 10px;
      }
      
      .yc-footer-logos {
        gap: 15px;
      }
      
      .yc-footer-logo img {
        max-height: 50px;
        max-width: 100px;
      }
      
      .yc-footer-eu-content {
        flex-direction: column;
        gap: 20px;
        text-align: center;
      }
      
      .yc-footer-eu-text {
        min-width: auto;
        max-width: none;
      }
      
      .yc-footer-eu-text p {
        font-size: 9pt;
      }
    }

    @media (max-width: 480px) {
      .yc-footer-logos {
        gap: 10px;
      }
      
      .yc-footer-logo img {
        max-height: 40px;
        max-width: 80px;
      }
      
      .yc-footer-eu-logo img {
        max-height: 60px;
        max-width: 150px;
      }
    }
  `;
  document.head.appendChild(style);
}

// Función para aplicar estilos CSS
function applyLocationColumnStyles() {
  const style = document.createElement('style');
  style.setAttribute('data-location-column', 'true');
  style.textContent = `
    .location-column-header {
      color: var(--text-primary) !important;
      font-weight: 600 !important;
      padding: 8px 12px !important;
      text-align: center !important;
      vertical-align: middle !important;
    }
    
    .location-column-data {
      color: var(--text-primary) !important;
      font-size: 0.9em !important;
      padding: 8px 12px !important;
      text-align: center !important;
      vertical-align: middle !important;
      transition: all 0.2s ease !important;
    }
    
    .location-column-data:hover {
      color: var(--text-primary) !important;
    }
    
    /* Estilos para tablas modernas de Discourse */
    .directory-table .location-column-header {
      color: var(--text-primary) !important;
      font-weight: 600 !important;
      padding: 8px 12px !important;
      text-align: center !important;
      vertical-align: middle !important;
    }
    
    .directory-table .location-column-data {
      color: var(--text-primary) !important;
      font-size: 0.9em !important;
      padding: 8px 12px !important;
      text-align: center !important;
      vertical-align: middle !important;
      transition: all 0.2s ease !important;
    }
    
    .directory-table .location-column-data:hover {
      color: var(--text-primary) !important;
    }
    
    /* Estilos para el filtro por ubicación */
    .location-filter-container {
      margin: 10px 0 !important;
      padding: 10px !important;
      background-color: var(--bg-tertiary) !important;
      border: 1px solid var(--border-primary) !important;
      border-radius: 4px !important;
      display: flex !important;
      align-items: center !important;
      gap: 10px !important;
    }
    
    .location-filter-container label {
      font-weight: 600 !important;
      color: var(--text-primary) !important;
      margin-right: 5px !important;
    }
    
    .location-filter-select {
      padding: 5px 10px !important;
      border: 1px solid #e0c052 !important;
      border-radius: 4px !important;
      background-color: var(--bg-primary) !important;
      color: var(--text-primary) !important;
      font-size: 14px !important;
      min-width: 150px !important;
    }
    
    .location-filter-select:hover {
      border-color: #d4b847 !important;
    }
    
    .location-filter-select:focus {
      outline: none !important;
      border-color: var(--text-secondary) !important;
      box-shadow: 0 0 0 2px rgba(138, 74, 25, 0.2) !important;
    }
    
    .location-filter-counter {
      color: var(--text-secondary) !important;
      font-weight: 500 !important;
      font-size: 14px !important;
    }
    
    .location-progress-indicator {
      color: var(--text-secondary) !important;
      font-size: 12px !important;
      font-style: italic !important;
      animation: pulse 2s infinite !important;
    }
    
    .loading-indicator {
      animation: pulse 1.5s infinite !important;
      color: #e0c052 !important;
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    /* Estilos para la tabla completa */
    .admin-users-table table,
    .admin-users table,
    .users-table table,
    .admin-users-list table,
    .admin-users-list,
    .directory-table {
      border-collapse: collapse !important;
    }
    
    .admin-users-table th,
    .admin-users-table td,
    .admin-users th,
    .admin-users td,
    .users-table th,
    .users-table td,
    .admin-users-list th,
    .admin-users-list td,
    .directory-table__column-header,
    .directory-table__cell {
    }
  `;
  document.head.appendChild(style);
}

// Función para limpiar la columna cuando se cambia de página
function cleanupLocationColumn() {
  const existingHeader = document.querySelector('.location-column-header');
  const existingCells = document.querySelectorAll('.location-column-data');
  const existingStyle = document.querySelector('style[data-location-column]');
  const existingFilter = document.querySelector('.location-filter-container');
  
  if (existingHeader) existingHeader.remove();
  existingCells.forEach(cell => cell.remove());
  if (existingStyle) existingStyle.remove();
  if (existingFilter) existingFilter.remove();
  
  // Resetear variables globales
  currentTable = null;
  currentDataRows = [];
  locationFilter = null;
  filterCounter = null;
  filterSelect = null;
}

// Función para limpiar el cache (útil para debugging o cuando se quiera refrescar datos)
function clearLocationCache() {
  userLocationCache.clear();
  localStorage.removeItem('userLocationCache');
  console.log('Cache de ubicaciones limpiado');
}

// Función para limpiar entradas problemáticas del cache
function cleanInvalidCacheEntries() {
  let cleaned = 0;
  const invalidPatterns = [
    'read time', 'last emailed', 'seen', 'topics viewed', 'posts read',
    'created', 'status', 'joined', 'posts', 'topics', 'likes', 'active',
    'admin', 'moderator', 'user', 'member', 'online', 'offline', 'away'
  ];
  
  for (const [username, location] of userLocationCache.entries()) {
    const lowerLocation = location.toLowerCase();
    let shouldDelete = false;
    
    // Verificar si contiene texto de UI inválido
    for (const pattern of invalidPatterns) {
      if (lowerLocation.includes(pattern)) {
        shouldDelete = true;
        break;
      }
    }
    
    if (shouldDelete) {
      userLocationCache.delete(username);
      cleaned++;
      console.log(`Limpiada entrada inválida del cache: ${username} -> "${location}"`);
    }
  }
  
  if (cleaned > 0) {
    saveCacheToStorage();
    console.log(`Limpiadas ${cleaned} entradas inválidas del cache`);
  }
}

// Función para limpiar entradas del cache que contengan fechas/horas
function cleanDateTimeCacheEntries() {
  let cleaned = 0;
  const dateTimePatterns = [
    /^\d{4} \d{1,2}:\d{2} [ap]m$/, // "2025 8:56 pm"
    /^[A-Za-z]{3} \d{1,2}, \d{4} \d{1,2}:\d{2} [ap]m$/, // "Sep 19, 2025 8:56 pm"
    /^[A-Za-z]{3} \d{1,2}, \d{4}$/, // "Sep 19, 2025"
    /^\d{1,2}:\d{2} [ap]m$/, // "8:56 pm"
    /^\d{4}$/, // "2025"
    /^\d{1,2}:\d{2}$/, // "8:56"
    /^[A-Za-z]{3} \d{1,2}$/, // "Sep 19"
    /^\d{1,2}\/\d{1,2}\/\d{4}$/, // "19/09/2025"
    /^\d{4}-\d{1,2}-\d{1,2}$/ // "2025-09-19"
  ];
  
  for (const [username, location] of userLocationCache.entries()) {
    for (const pattern of dateTimePatterns) {
      if (pattern.test(location)) {
        userLocationCache.delete(username);
        cleaned++;
        console.log(`Limpiada entrada de fecha/hora del cache: ${username} -> "${location}"`);
        break;
      }
    }
  }
  
  if (cleaned > 0) {
    saveCacheToStorage();
    console.log(`Limpiadas ${cleaned} entradas de fecha/hora del cache`);
  }
}

// Función para mostrar estadísticas del cache (útil para debugging)
function showCacheStats() {
  const cacheSize = userLocationCache.size;
  const localStorageSize = localStorage.getItem('userLocationCache') ? JSON.parse(localStorage.getItem('userLocationCache')).length : 0;
  
  console.log(`Estadísticas del cache:
    - Ubicaciones en cache: ${cacheSize}
    - Tamaño del cache en localStorage: ${localStorageSize} items`);
  
  return { cacheSize, localStorageSize };
}

// Función para debuggear el DOM de un usuario específico
function debugUserDOM(username) {
  console.log(`=== DEBUG DOM para usuario: ${username} ===`);
  
  const userRow = document.querySelector(`a[href*="/u/${username}"]`)?.closest('.directory-table__row, tr');
  
  if (!userRow) {
    console.log(`No se encontró fila para usuario ${username}`);
    return;
  }
  
  console.log(`Fila encontrada para usuario ${username}:`);
  console.log(userRow);
  
  // Mostrar todo el contenido de texto de la fila
  const allElements = userRow.querySelectorAll('*');
  console.log(`Total de elementos en la fila: ${allElements.length}`);
  
  const textContents = [];
  allElements.forEach((element, index) => {
    const text = element.textContent.trim();
    if (text && text.length > 0 && text.length < 100) {
      textContents.push({
        index: index,
        tagName: element.tagName,
        className: element.className,
        text: text
      });
    }
  });
  
  console.log('Contenidos de texto encontrados:');
  textContents.forEach(item => {
    console.log(`[${item.index}] ${item.tagName}.${item.className}: "${item.text}"`);
  });
  
  // Mostrar atributos de todos los elementos
  console.log('Atributos encontrados:');
  allElements.forEach((element, index) => {
    const attributes = element.attributes;
    if (attributes.length > 0) {
      console.log(`[${index}] ${element.tagName}.${element.className}:`);
      for (const attr of attributes) {
        if (attr.value && attr.value.length > 0 && attr.value.length < 100) {
          console.log(`  ${attr.name}: "${attr.value}"`);
        }
      }
    }
  });
  
  console.log(`=== FIN DEBUG DOM para usuario: ${username} ===`);
}

// Función para debuggear el tercer scroll específicamente
function debugThirdScroll() {
  console.log('=== DEBUG TERCER SCROLL ===');
  
  if (!currentTable) {
    console.log('No hay tabla actual');
    return;
  }
  
  const allRows = currentTable.querySelectorAll('.directory-table__row, tr');
  console.log(`Total de filas en la tabla: ${allRows.length}`);
  
  // Buscar filas sin columna de ubicación
  const rowsWithoutLocation = [];
  allRows.forEach((row, index) => {
    if (!row.querySelector('.location-column-data')) {
      rowsWithoutLocation.push({ index, row });
    }
  });
  
  console.log(`Filas sin columna de ubicación: ${rowsWithoutLocation.length}`);
  
  if (rowsWithoutLocation.length > 0) {
    console.log('Primeras 3 filas sin ubicación:');
    rowsWithoutLocation.slice(0, 3).forEach(({ index, row }) => {
      const usernameLink = row.querySelector('a[href*="/u/"]');
      const username = usernameLink ? usernameLink.href.split('/u/')[1] : 'unknown';
      console.log(`Fila ${index}: ${username}`);
      console.log('Contenido:', row.textContent.trim().substring(0, 200) + '...');
    });
  }
  
  console.log('=== FIN DEBUG TERCER SCROLL ===');
}

// Función para mostrar estadísticas de la cola de peticiones
function showQueueStats() {
  console.log(`Estadísticas de la cola:
    - Peticiones en cola: ${requestQueue.length}
    - Procesando cola: ${isProcessingQueue}
    - Última petición: ${lastRequestTime ? new Date(lastRequestTime).toLocaleTimeString() : 'Nunca'}
    - Intervalo mínimo: ${MIN_REQUEST_INTERVAL}ms`);
}

// Hacer funciones disponibles globalmente para debugging
window.clearLocationCache = clearLocationCache;
window.cleanInvalidCacheEntries = cleanInvalidCacheEntries;
window.cleanDateTimeCacheEntries = cleanDateTimeCacheEntries;
window.showCacheStats = showCacheStats;
window.showQueueStats = showQueueStats;
// Función de debug específica para un usuario
function debugSpecificUser(username) {
  console.log(`=== DEBUG USUARIO: ${username} ===`);
  
  if (!currentTable) {
    console.log('No hay tabla actual');
    return;
  }
  
  // Buscar la fila del usuario
  const userRow = currentTable.querySelector(`a[href*="/u/${username}"]`)?.closest('.directory-table__row, tr');
  if (!userRow) {
    console.log(`No se encontró la fila del usuario ${username}`);
    return;
  }
  
  console.log(`Fila encontrada para usuario ${username}`);
  
  // Buscar el enlace del usuario
  const userLink = userRow.querySelector(`a[href*="/u/${username}"]`);
  if (!userLink) {
    console.log(`No se encontró el enlace del usuario ${username}`);
    return;
  }
  
  console.log(`Enlace encontrado: ${userLink.href}`);
  
  // Buscar el userCard
  const userCard = userLink.closest('.user-card, .directory-table__row, tr');
  if (!userCard) {
    console.log(`No se encontró el userCard del usuario ${username}`);
    return;
  }
  
  console.log(`UserCard encontrado para usuario ${username}`);
  
  // Buscar todos los elementos de texto
  const textElements = userCard.querySelectorAll('span, div, p, td');
  console.log(`Encontrados ${textElements.length} elementos de texto para usuario ${username}`);
  
  // Mostrar todos los textos encontrados
  textElements.forEach((element, index) => {
    const text = element.textContent.trim();
    if (text && text.length > 0) {
      console.log(`Elemento ${index}: "${text}"`);
      
      // Verificar si es una ubicación válida
      if (isValidLocationSimple(text)) {
        console.log(`  → VÁLIDO como ubicación`);
      } else {
        console.log(`  → Rechazado como ubicación`);
      }
    }
  });
  
  // Intentar extraer ubicación manualmente
  console.log(`Intentando extraer ubicación para ${username}...`);
  const extractedLocation = extractLocationFromDOM(username);
  console.log(`Ubicación extraída: "${extractedLocation}"`);
  
  console.log(`=== FIN DEBUG USUARIO: ${username} ===`);
}

// Función de debug para el filtro
function debugFilter(selectedLocation) {
  console.log(`=== DEBUG FILTRO: "${selectedLocation}" ===`);
  
  if (!currentTable) {
    console.log('No hay tabla actual');
    return;
  }
  
  const allRows = currentTable.querySelectorAll('.directory-table__row, tr');
  console.log(`Total de filas: ${allRows.length}`);
  
  const locationStats = {};
  let visibleCount = 0;
  
  allRows.forEach((row, index) => {
    const locationCell = row.querySelector('.location-column-data');
    if (locationCell) {
      const cellLocation = locationCell.textContent.trim();
      
      // Contar estadísticas
      if (!locationStats[cellLocation]) {
        locationStats[cellLocation] = 0;
      }
      locationStats[cellLocation]++;
      
      // Verificar si debería ser visible con el filtro actual
      let shouldShow = false;
      
      if (selectedLocation === 'all') {
        shouldShow = true;
      } else if (selectedLocation === 'no-location') {
        shouldShow = (cellLocation === 'N/A' || cellLocation === 'Sin ubicación' || cellLocation === '...');
      } else {
        const cellLocationLower = cellLocation.toLowerCase();
        const selectedLocationLower = selectedLocation.toLowerCase();
        
        shouldShow = (cellLocationLower === selectedLocationLower) || 
                    cellLocationLower.includes(selectedLocationLower);
      }
      
      if (shouldShow) visibleCount++;
      
      // Mostrar las primeras 10 filas para debug
      if (index < 10) {
        console.log(`Fila ${index}: "${cellLocation}" ${shouldShow ? 'VISIBLE' : 'OCULTA'}`);
      }
    }
  });
  
  console.log(`Usuarios visibles con filtro "${selectedLocation}": ${visibleCount}`);
  console.log('Estadísticas de ubicaciones:');
  Object.entries(locationStats).forEach(([location, count]) => {
    console.log(`  "${location}": ${count} usuarios`);
  });
  
  console.log(`=== FIN DEBUG FILTRO ===`);
}

window.debugUserDOM = debugUserDOM;
window.debugThirdScroll = debugThirdScroll;
window.debugSpecificUser = debugSpecificUser;
window.debugFilter = debugFilter;

// Función de debug específica para el problema del filtro
window.debugFilterIssue = function() {
  console.log('=== DEBUG FILTRO ISSUE ===');
  
  if (!currentTable) {
    console.log('No hay tabla actual');
    return;
  }
  
  const allRows = currentTable.querySelectorAll('.directory-table__row, tr');
  console.log(`Total de filas en DOM: ${allRows.length}`);
  console.log(`currentDataRows.length: ${currentDataRows.length}`);
  
  const rowsWithLocation = allRows.filter(row => row.querySelector('.location-column-data'));
  console.log(`Filas con columna de ubicación: ${rowsWithLocation.length}`);
  
  const visibleRows = allRows.filter(row => !row.style.display || row.style.display !== 'none');
  console.log(`Filas visibles: ${visibleRows.length}`);
  
  if (filterSelect) {
    console.log(`Filtro actual: "${filterSelect.value}"`);
  }
  
  // Mostrar las primeras 10 filas con su estado
  console.log('Primeras 10 filas:');
  allRows.slice(0, 10).forEach((row, index) => {
    const locationCell = row.querySelector('.location-column-data');
    const location = locationCell ? locationCell.textContent.trim() : 'N/A (sin columna)';
    const isVisible = !row.style.display || row.style.display !== 'none';
    console.log(`  ${index}: "${location}" - ${isVisible ? 'VISIBLE' : 'OCULTA'}`);
  });
  
  console.log('=== FIN DEBUG FILTRO ISSUE ===');
};

// Función de debug específica para probar casos problemáticos de países
window.debugCountryMatching = function(country1, country2) {
  console.log(`=== DEBUG MATCHING DE PAÍSES: "${country1}" vs "${country2}" ===`);
  
  if (!currentTable) {
    console.log('No hay tabla actual');
    return;
  }
  
  const allRows = currentTable.querySelectorAll('.directory-table__row, tr');
  const rowsWithLocation = allRows.filter(row => row.querySelector('.location-column-data'));
  
  console.log(`Probando matching para "${country1}":`);
  rowsWithLocation.forEach((row, index) => {
    const locationCell = row.querySelector('.location-column-data');
    const cellLocation = locationCell.textContent.trim();
    
    // Simular la lógica de matching
    const cellLocationLower = cellLocation.toLowerCase();
    const selectedLocationLower = country1.toLowerCase();
    
    let shouldShow = false;
    
    // Comparación exacta
    shouldShow = (cellLocationLower === selectedLocationLower);
    
    // Si no coincide exactamente, verificar si contiene la ubicación seleccionada
    if (!shouldShow && cellLocationLower.includes(selectedLocationLower)) {
      shouldShow = true;
    }
    
    // Verificar casos especiales con matching más estricto
    if (!shouldShow) {
      const cellWords = cellLocationLower.split(/[\s,.-]+/).filter(word => word.length > 2);
      const selectedWords = selectedLocationLower.split(/[\s,.-]+/).filter(word => word.length > 2);
      
      if (selectedWords.length >= 2) {
        const commonWords = selectedWords.filter(selectedWord => 
          cellWords.some(cellWord => cellWord === selectedWord)
        );
        shouldShow = commonWords.length >= 2;
      } else if (selectedWords.length === 1) {
        shouldShow = cellWords.some(cellWord => cellWord === selectedWords[0]);
      }
    }
    
    if (shouldShow) {
      console.log(`  ✓ "${cellLocation}" MATCH con "${country1}"`);
    }
  });
  
  console.log(`\nProbando matching para "${country2}":`);
  rowsWithLocation.forEach((row, index) => {
    const locationCell = row.querySelector('.location-column-data');
    const cellLocation = locationCell.textContent.trim();
    
    // Simular la lógica de matching
    const cellLocationLower = cellLocation.toLowerCase();
    const selectedLocationLower = country2.toLowerCase();
    
    let shouldShow = false;
    
    // Comparación exacta
    shouldShow = (cellLocationLower === selectedLocationLower);
    
    // Si no coincide exactamente, verificar si contiene la ubicación seleccionada
    if (!shouldShow && cellLocationLower.includes(selectedLocationLower)) {
      shouldShow = true;
    }
    
    // Verificar casos especiales con matching más estricto
    if (!shouldShow) {
      const cellWords = cellLocationLower.split(/[\s,.-]+/).filter(word => word.length > 2);
      const selectedWords = selectedLocationLower.split(/[\s,.-]+/).filter(word => word.length > 2);
      
      if (selectedWords.length >= 2) {
        const commonWords = selectedWords.filter(selectedWord => 
          cellWords.some(cellWord => cellWord === selectedWord)
        );
        shouldShow = commonWords.length >= 2;
      } else if (selectedWords.length === 1) {
        shouldShow = cellWords.some(cellWord => cellWord === selectedWords[0]);
      }
    }
    
    if (shouldShow) {
      console.log(`  ✓ "${cellLocation}" MATCH con "${country2}"`);
    }
  });
  
  console.log('=== FIN DEBUG MATCHING DE PAÍSES ===');
};

// Función principal que se ejecuta cuando Discourse esté listo
async function initLocationColumn() {
  try {
    // Esperar a que Discourse esté completamente cargado
    await waitForDiscourse();
    
    console.log('Inicializando columna Location...');
    
    // Ejecutar cuando se carga la página
    await addLocationColumn();
    
    // Configurar navegación para paginación
    setupNavigationHandlers();
    
    console.log('Columna Location inicializada correctamente');
    
  } catch (error) {
    console.log('Error inicializando columna Location:', error);
  }
}

// Aplicar estilos del footer inmediatamente al cargar la página
applyFooterStyles();

// Iniciar cuando el DOM esté listo
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initLocationColumn);
} else {
  initLocationColumn();
}
</script>
